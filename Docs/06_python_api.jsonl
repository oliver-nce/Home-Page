{"chunk_id": "06_python_api__api__realtime__001", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/realtime", "title": "Realtime", "section_heading": "frappe.realtime.on", "content": "## frappe.realtime.on\n\nFrappe ships with an API for realtime events based on [socket.io](https://socket.io/). Since socket.io needs a Node server to run, we run a Node process in parallel to the main web server.\n\n### frappe.realtime.on\n\nTo listen to realtime events on the client (browser), you can use the `frappe.realtime.on` method:\n\n```python\nfrappe.realtime.on('event_name', (data) => {\n console.log(data)\n})\n```\n\n### frappe.realtime.off\n\nStop listening to an event you have subscribed to:\n\n```python\nfrappe.realtime.off('event_name')\n```\n\n### frappe.publish\\_realtime\n\nTo publish a realtime event from the server, you can use the `frappe.publish_realtime` method:\n\n```python\nfrappe.publish_realtime('event_name', data={'key': 'value'})\n```\n\n### frappe.publish\\_progress\n\nYou can use this method to show a progress bar in a dialog:\n\n```python\nfrappe.publish_progress(25, title='Some title', description='Some description')\n```\n\n![frappe publish realtime](/files/frappe-publish-realtime.png)", "content_type": "mixed", "has_code": true, "token_count": 248}
{"chunk_id": "06_python_api__api__background_jobs__001", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/background_jobs", "title": "Background Jobs", "section_heading": "Queue", "content": "## Queue\n\nFrappe ships with a system for running jobs in the background. It is implemented by using the [schedule package](https://pypi.org/project/schedule/) and a simple long-running infinite [while loop](https://github.com/frappe/frappe/blob/d0efa8e3ff734268a30b4804427641d2a5ed643e/frappe/utils/scheduler.py#L36-L46).\n\nYou can enqueue a python method to run in the background by using the `frappe.enqueue` method:\n\n```python\ndef long_running_job(param1, param2):\n # expensive tasks\n pass\n\n# directly pass the function\nfrappe.enqueue(long_running_job, queue='short', param1='A', param2='B')\n\n# or pass the full module path as string\nfrappe.enqueue('app.module.folder.long_running_job', queue='short', param1='A', param2='B')\n```\n\nHere are all the possible arguments you can pass to the `enqueue`:\n\n```python\nfrappe.enqueue(\n method, # python function or a module path as string\n queue=\"default\", # one of short, default, long\n timeout=None, # pass timeout manually\n is_async=True, # if this is True, method is run in worker\n now=False, # if this is True, method is run directly (not in a worker) \n job_name=None, # specify a job name\n enqueue_after_commit=False, # enqueue the job after the database commit is done at the end of the request\n at_front=False, # put the job at the front of the queue\n **kwargs, # kwargs are passed to the method as arguments\n)\n```\n\nYou can also enqueue a [Document](https://frappeframework.com/docs/v14/user/en/api/document) method by using `frappe.enqueue_doc`:\n\n```python\nfrappe.enqueue_doc(\n doctype,\n name,\n \"do_something\", # name of the controller method\n queue=\"long\",\n timeout=4000,\n param=\"value\"\n)\n```\n\n### Queue\n\nThere are 3 default queues that are configured with the framework: `short`, `default`, and `long`. Each queue has a default timeout as follows:\n\n* short: 300 seconds\n* default: 300 seconds\n* long: 1500 seconds\n\nYou can also pass a custom timeout to the `enqueue` method.\n\n### Custom Queues\n\nYou can add custom queues by configuring them in `[common_site_config.json](https://frappeframework.com/docs/v14/user/en/basics/site_config#common-site-config)`:\n\n```python\n{\n ...\n \"workers\": {\n \"myqueue\": {\n \"timeout\": 5000, # queue timeout\n \"background_workers\": 4, # number of workers for this queue\n } \n }\n}\n```", "content_type": "mixed", "has_code": true, "token_count": 565}
{"chunk_id": "06_python_api__api__background_jobs__002", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/background_jobs", "title": "Background Jobs", "section_heading": "Workers", "content": "## Workers\n\nBy default Frappe sets up 3 worker types for consuming from each queue. The default configuration looks like this:\n\n```python\nbench worker --queue short\nbench worker --queue default\nbench worker --queue long\n```\n\nIn production these 3 worker processes are replicated to configured number of background workers to handle higher workloads.\n\nNOTE: This way of mapping workers to single queue is just a convention and it's not necessary to follow it.\n\n### Multi-queue consumption\n\nYou can specify more than one queue for workers to consume from by specifying a comma separate string of queue names.\n\nExample: If you wanted to combine short and default workers and only use two types of workers instead of default configuration then you can modify your worker configuration like this:\n\n```python\nbench worker --queue short,default\nbench worker --queue long\n```\n\nNOTE: The examples shown here are for Procfile format but they can be applied to supervisor or systemd configurations easily too.\n\n### Burst Mode using `--burst`\n\n```python\nbench worker --queue short --burst\n```\n\nThis command will spawn a tempoary worker that will start consuming short queue and quit once queue is empty. If you periodically need higher amount of workers then you can use your OS's crontab to setup burst workers at specific times.", "content_type": "mixed", "has_code": true, "token_count": 329}
{"chunk_id": "06_python_api__api__background_jobs__003", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/background_jobs", "title": "Background Jobs", "section_heading": "Scheduler Events", "content": "## Scheduler Events\n\nYou can use Scheduler Events for running tasks periodically in the background using the `scheduler_events` hook.\n\n**app/hooks.py**\n\n```python\nscheduler_events = {\n \"hourly\": [\n # will run hourly\n \"app.scheduled_tasks.update_database_usage\"\n ],\n}\n```\n\n**app/scheduled\\_tasks.py**\n\n```python\ndef update_database_usage():\n pass\n```\n\n> After changing any scheduled events in hooks.py, you need to run bench migrate for changes to take effect.\n\n### Available Events\n\n* `hourly`, `daily`, `weekly`, and `monthly`\n\nThese events will trigger every hour, day, week, and month respectively.\n\n* `hourly_long`, `daily_long`, `weekly_long`, `monthly_long`\n\nSame as above but these jobs are run in the [long worker](https://frappeframework.com/docs/v14/user/en/basics/directory-structure#worker_long) suitable for long-running jobs.\n\n* `all`\n\nThe `all` event is triggered every 60 seconds. This can be configured via the `scheduler_tick_interval` key in `[common_site_config.json](https://frappeframework.com/docs/v14/user/en/basics/sites#scheduler_tick_interval)`\n\n* `cron`\n\nA valid cron string that can be parsed by [croniter](https://pypi.org/project/croniter/).\n\nUsage Examples:\n\n```python\nscheduler_events = {\n \"daily\": [\n \"app.scheduled_tasks.manage_recurring_invoices\"\n ],\n \"daily_long\": [\n \"app.scheduled_tasks.take_backups_daily\"\n ],\n \"cron\": {\n \"15 18 * * *\": [\n \"app.scheduled_tasks.delete_all_barcodes_for_users\"\n ],\n \"*/6 * * * *\": [\n \"app.scheduled_tasks.collect_error_snapshots\"\n ],\n \"annual\": [\n \"app.scheduled_tasks.collect_error_snapshots\"\n ]\n }\n}\n```", "content_type": "mixed", "has_code": true, "token_count": 394}
{"chunk_id": "06_python_api__api__document__001", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/document", "title": "Document", "section_heading": "frappe.get\\_doc", "content": "## frappe.get\\_doc\n\nA Document is an instance of a DocType. It is derived from the\n`frappe.model.Document` class and represents a single record in the database\ntable.\n\n### frappe.get\\_doc\n\n`frappe.get_doc(doctype, name)`\n\nReturns a Document object of\nthe record identified by `doctype` and `name`. If no document is found, a\n`DoesNotExistError` is raised. If `doctype` is a Single DocType `name` is not\nrequired.\n\n```python\n# get an existing document\ndoc = frappe.get_doc('Task', 'TASK00002')\ndoc.title = 'Test'\ndoc.save()\n\n# get a single doctype\ndoc = frappe.get_doc('System Settings')\ndoc.timezone # Asia/Kolkata\n```\n\n`frappe.get_doc(dict)`\n\nReturns a new Document object in memory which does not exist yet in the\ndatabase.\n\n```python\n# create a new document\ndoc = frappe.get_doc({\n 'doctype': 'Task',\n 'title': 'New Task'\n})\ndoc.insert()\n```\n\n`frappe.get_doc(doctype={document_type}, key1 = value1, key2 = value2, ...)`\n\nReturns a new Document object in memory which does not exist yet in the\ndatabase.\n\n```python\n# create new object with keyword arguments\nuser = frappe.get_doc(doctype='User', email_id='test@example.com')\nuser.insert()\n```", "content_type": "mixed", "has_code": true, "token_count": 286}
{"chunk_id": "06_python_api__api__document__002", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/document", "title": "Document", "section_heading": "frappe.get\\\\_last\\\\_doc", "content": "## frappe.get\\\\_last\\\\_doc\n\n`frappe.get_last_doc(doctype, filters, order_by)`\n\nReturns the last Document object created under the mentioned `doctype`.\n\n```python\n# get the last Task created\ntask = frappe.get_last_doc('Task')\n```\n\nYou can also specify filters to refine your results. For instance, you can\nretrieve the last canceled Task by adding a filter.\n\n```python\n# get the last available Cancelled Task\ntask = frappe.get_last_doc('Task', filters={\"status\": \"Cancelled\"})\n```\n\nBy default, the `order_by` argument is set to `creation desc`, but this value\ncan be overridden to use other non-standard fields that can serve the same\npurpose. For instance, you have a field `timestamp` under the **Task** DocType\nthat tracks the time it was approved or marked valid instead of the time it was\ncreated.\n\n```python\n# get the last Task created based on a non-standard field\ntask = frappe.get_last_doc('Task', filters={\"Status\": \"Cancelled\"}, order_by=\"timestamp desc\")\n```\n\nAlternatively, you can choose to go completely against all of this and as a part\nof a joke change it to \"creation asc\" to retrieve the first document instead.\n\n### frappe.get\\\\_cached\\\\_doc\n\nSimilar to `frappe.get_doc` but will look up the document in cache first before\nhitting the database.\n\n### frappe.new\\_doc\n\n`frappe.new_doc(doctype)`\n\nAlternative way to create a new Document.\n\n```python\n# create a new document\ndoc = frappe.new_doc('Task')\ndoc.title = 'New Task 2'\ndoc.insert()\n```\n\n### frappe.delete\\_doc\n\n`frappe.delete_doc(doctype, name)`\n\nDeletes the record and its children from the database. Also deletes other\ndocuments like Communication, Comments, etc linked to it.\n\n```python\nfrappe.delete_doc('Task', 'TASK00002')\n```\n\n### frappe.rename\\_doc\n\n`frappe.rename_doc(doctype, old_name, new_name, merge=False)`\n\nRename a document's `name` (primary key) from `old_name` to `new_name`. If\n`merge` is `True` and a record with `new_name` exists, will merge the record\nwith it.\n\n```python\nfrappe.rename_doc('Task', 'TASK00002', 'TASK00003')\n```\n\n> Rename will only work if **Allow Rename** is set in the DocType Form.\n\n### frappe.get\\_meta\n\n`frappe.get_meta(doctype)`\n\nReturns meta information of `doctype`. This will also apply custom fields and\nproperty setters.\n\n```python\nmeta = frappe.get_meta('Task')\nmeta.has_field('status') # True\nmeta.get_custom_fields() # [field1, field2, ..]\n```\n\nTo get the original document of DocType (without custom fields and property\nsetters) use `frappe.get_doc('DocType', doctype_name)`\n\n### Document Methods\n\nThis section lists out common methods that are available on the `doc` object.", "content_type": "mixed", "has_code": true, "token_count": 650}
{"chunk_id": "06_python_api__api__document__003", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/document", "title": "Document", "section_heading": "doc.insert", "content": "## doc.insert\n\nThis method inserts a new document into the database table. It will check for\nuser permissions and execute `before_insert`, `validate`, `on_update`,\n`after_insert` methods if they are written in the controller.\n\nIt has some escape hatches that can be used to skip certain checks explained\nbelow.\n\n```python\ndoc.insert(\n ignore_permissions=True, # ignore write permissions during insert\n ignore_links=True, # ignore Link validation in the document\n ignore_if_duplicate=True, # dont insert if DuplicateEntryError is thrown\n ignore_mandatory=True # insert even if mandatory fields are not set\n)\n```\n\n### doc.save\n\nThis method saves changes to an existing document. This will check for user\npermissions and execute `validate` before updating and `on_update` after\nupdating values.\n\n```python\ndoc.save(\n ignore_permissions=True, # ignore write permissions during insert\n ignore_version=True # do not create a version record\n)\n```\n\n### doc.delete\n\nDelete the document record from the database table. This method is an alias to\n`frappe.delete_doc`.\n\n```python\ndoc.delete()\n```\n\n### doc.get\\\\_doc\\\\_before\\\\_save\n\nWill return a version of the doc before the changes were made. You can use it to\ncompare what changed from the last version.\n\n```python\nold_doc = doc.get_doc_before_save()\nif old_doc.price != doc.price:\n # price changed\n pass\n```\n\n### doc.reload\n\nWill get the latest values from the database and update the doc state.\n\nWhen you are working with a document, it may happen that some other part of code\nupdates the value of some field directly in the database. In such cases you can\nuse this method to reload the doc.\n\n```python\ndoc.reload()\n```\n\n### doc.check\\_permission\n\nThrow if the current user has no permission for the provided permtype.\n\n```python\ndoc.check_permission(permtype='write') # throws if no write permission\n```\n\n### doc.get\\_title\n\nGet the document title based on `title_field` or field named **title** or\n**name**.\n\n```python\ntitle = doc.get_title()\n```\n\n### doc.notify\\_update\n\nPublish realtime event to indicate that the document has been modified. Client\nside event handlers react to this event by updating the form.\n\n```python\ndoc.notify_update()\n```", "content_type": "mixed", "has_code": true, "token_count": 548}
{"chunk_id": "06_python_api__api__document__004", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/document", "title": "Document", "section_heading": "doc.db\\_set", "content": "## doc.db\\_set\n\nSet a field value of the document directly in the database and update the\nmodified timestamp.\n\n> This method does not trigger controller validations and should be used very\n> carefully.\n\n```python\n# updates value in database, updates the modified timestamp\ndoc.db_set('price', 2300)\n\n# updates value in database, will trigger doc.notify_update()\ndoc.db_set('price', 2300, notify=True)\n\n# updates value in database, will also run frappe.db.commit()\ndoc.db_set('price', 2300, commit=True)\n\n# updates value in database, does not update the modified timestamp\ndoc.db_set('price', 2300, update_modified=False)\n```\n\n### doc.append\n\nAppend a new item to a child table.\n\n```python\ndoc.append(\"childtable\", {\n \"child_table_field\": \"value\",\n \"child_table_int_field\": 0,\n ...\n})\n```\n\n### doc.get\\_url\n\nReturns Desk URL for this document. For e.g: `/app/task/TASK00002`\n\n```python\nurl = doc.get_url()\n```\n\n### doc.add\\_comment\n\nAdd a comment to this document. Will show up in timeline in Form view.\n\n```python\n# add a simple comment\ndoc.add_comment('Comment', text='Test Comment')\n\n# add a comment of type Edit\ndoc.add_comment('Edit', 'Values changed')\n\n# add a comment of type Shared\ndoc.add_comment(\"Shared\", \"{0} shared this document with everyone\".format(user))\n```\n\n### doc.add\\_seen\n\nAdd the given/current user to list of users who have seen this document. Will\nupdate the `_seen` column in the table. It is stored as a JSON Array.\n\n```python\n# add john to list of seen\ndoc.add_seen('john@doe.com')\n\n# add session user to list of seen\ndoc.add_seen()\n```\n\n> This works only if **Track Seen** is enabled in the DocType.\n\n### doc.add\\_viewed\n\nAdd a view log when a user views a document i.e opens the Form.\n\n```python\n# add a view log by john\ndoc.add_viewed('john@doe.com')\n\n# add a view log by session user\ndoc.add_viewed()\n```\n\n> This works only if **Track Views** is enabled in the DocType.\n\n### doc.add\\_tag\n\nAdd a tag to a document. Tags are generally used to filter and group documents.\n\n```python\n# add tags\ndoc.add_tag('developer')\ndoc.add_tag('frontend')\n```\n\n### doc.get\\_tags\n\nReturns a list of tags associated with the specific document.\n\n```python\n# get all tags\ndoc.get_tags()\n```\n\n### doc.run\\_method\n\nRun method if defined in controller, will also trigger hooks if defined.\n\n```python\ndoc.run_method('validate')\n```\n\n### doc.queue\\_action\n\nRun a controller method in background. If the method has an inner function, like\n`_submit` for `submit`, it will call that method instead.\n\n```python\ndoc.queue_action('send_emails', emails=email_list, message='Howdy')\n```", "content_type": "mixed", "has_code": true, "token_count": 646}
{"chunk_id": "06_python_api__api__document__005", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/document", "title": "Document", "section_heading": "doc.get\\_children()", "content": "## doc.get\\_children()\n\n> Only available on tree DocTypes (inherited from `NestedSet`).\n\nReturns a generator that yields an instance of `NestedSet` for each child record.\n\n```python\nfor child_doc in doc.get_children():\n print(child_doc.name)\n```\n\nIt can also be applied recursively:\n\n```python\nfor child_doc in doc.get_children():\n print(child_doc.name)\n for grandchild_doc in child_doc.get_children():\n print(grandchild_doc.name)\n```\n\n### doc.get\\_parent()\n\n> Only available on tree DocTypes (inherited from `NestedSet`).\n\nReturns an instance of `NestedSet` for the parent record.\n\n```python\nparent_doc = doc.get_parent()\ngrandparent_doc = parent_doc.get_parent()\n```\n\n### doc.db\\_insert()\n\nSerialize and insert a document into database. Warning: This bypasses all validations and controller methods that might be required to run before and after inserting. When in doubt use `doc.insert()` instead.\n\n```python\ndoc = frappe.get_doc(doctype=\"Controller\", data=\"\")\ndoc.db_insert()\n```\n\n### doc.db\\_update()\n\nSerialize and update a document into database. Warning: This bypasses all validations and controller methods that might be required to run before and after updating. When in doubt use `doc.save()` instead.\n\n```python\ndoc = frappe.get_last_doc(\"User\")\ndoc.last_active = now()\ndoc.db_update()\n```", "content_type": "mixed", "has_code": true, "token_count": 325}
{"chunk_id": "06_python_api__api__database__001", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/database", "title": "Database", "section_heading": "frappe.db.get\\_list", "content": "## frappe.db.get\\_list\n\n`frappe.db.get_list(doctype, filters, or_filters, fields, order_by, group_by, start, page_length)`\n\n* Also aliased to `frappe.get_list`\n\nReturns a list of records from a `doctype` table. ORM Wrapper for a `SELECT` query. Will also apply user permissions for the records for the session user. Only returns the document names if the `fields` keyword argument is not given. By default this method returns a list of `dict`s, but, you can pluck a particular field by giving the `pluck` keyword argument:\n\n```python\nfrappe.db.get_list('Employee')\n\n# output\n[{'name': 'HR-EMP-00008'},\n {'name': 'HR-EMP-00006'},\n {'name': 'HR-EMP-00010'},\n {'name': 'HR-EMP-00005'}\n]\n\n# with pluck\nfrappe.db.get_list('Employee', pluck='name')\n\n# output\n['HR-EMP-00008',\n 'HR-EMP-00006',\n 'HR-EMP-00010',\n 'HR-EMP-00005'\n]\n```\n\nCombining filters and other arguments:\n\n```python\nfrappe.db.get_list('Task',\n    filters={\n        'status': 'Open'\n    },\n    fields=['subject', 'date'],\n    order_by='date desc',\n    start=10,\n    page_length=20,\n    as_list=True\n)\n\n# output\n(('Update Branding and Design', '2019-09-04'),\n('Missing Documentation', '2019-09-02'),\n('Fundraiser for Foundation', '2019-09-03'))\n\n# Tasks with date after 2019-09-08\nfrappe.db.get_list('Task', filters={\n    'date': ['>', '2019-09-08']\n})\n\n# Tasks with date between 2020-04-01 and 2021-03-31 (both inclusive)\nfrappe.db.get_list('Task', filters=[[\n    'date', 'between', ['2020-04-01', '2021-03-31']\n]])\n\n# Tasks with subject that contains \"test\"\nfrappe.db.get_list('Task', filters={\n    'subject': ['like', '%test%']\n})\n\n# Count number of tasks grouped by status\nfrappe.db.get_list('Task',\n    fields=['count(name) as count', 'status'],\n    group_by='status'\n)\n# output\n[{'count': 1, 'status': 'Working'},\n {'count': 2, 'status': 'Overdue'},\n {'count': 2, 'status': 'Open'},\n {'count': 1, 'status': 'Filed'},\n {'count': 20, 'status': 'Completed'},\n {'count': 1, 'status': 'Cancelled'}]\n```\n\n### frappe.db.get\\_all\n\n`frappe.db.get_all(doctype, filters, or_filters, fields, order_by, group_by, start, page_length)`\n\n* Also aliased to `frappe.get_all`\n\nSame as `frappe.db.get_list` but will fetch all records without applying permissions.", "content_type": "mixed", "has_code": true, "token_count": 552}
{"chunk_id": "06_python_api__api__database__002", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/database", "title": "Database", "section_heading": "frappe.db.get\\_value", "content": "## frappe.db.get\\_value\n\n`frappe.db.get_value(doctype, name, fieldname)` or `frappe.db.get_value(doctype, filters, fieldname)`\n\n* Also aliased to `frappe.get_value` and `frappe.db.get_values`\n\nReturns a document's field value or a list of values.\n\n```python\n# single value\nsubject = frappe.db.get_value('Task', 'TASK00002', 'subject')\n\n# multiple values\nsubject, description = frappe.db.get_value('Task', 'TASK00002', ['subject', 'description'])\n\n# as dict\ntask_dict = frappe.db.get_value('Task', 'TASK00002', ['subject', 'description'], as_dict=1)\ntask_dict.subject\ntask_dict.description\n\n# with filters, will return the first record that matches filters\nsubject, description = frappe.db.get_value('Task', {'status': 'Open'}, ['subject', 'description'])\n```\n\n### frappe.db.get\\_single\\_value\n\n`frappe.db.get_single_value(doctype, fieldname)`\n\nReturns a field value from a Single DocType.\n\n```python\ntimezone = frappe.db.get_single_value('System Settings', 'timezone')\n```", "content_type": "mixed", "has_code": true, "token_count": 243}
{"chunk_id": "06_python_api__api__database__003", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/database", "title": "Database", "section_heading": "frappe.db.set\\_value", "content": "## frappe.db.set\\_value\n\n`frappe.db.set_value(doctype, name, fieldname, value)`\n\n* Also aliased to `frappe.db.update`\n\nSets a field's value in the database, does not call the ORM triggers but updates the modified timestamp (unless specified not to).\n\n```python\n# update a field value\nfrappe.db.set_value('Task', 'TASK00002', 'subject', 'New Subject')\n\n# update multiple values\nfrappe.db.set_value('Task', 'TASK00002', {\n    'subject': 'New Subject',\n    'description': 'New Description'\n})\n\n# update without updating the `modified` timestamp\nfrappe.db.set_value('Task', 'TASK00002', 'subject', 'New Subject', update_modified=False)\n```\n\n> This method won't call ORM triggers like `validate` and `on_update`. Use this method to update hidden fields or if you know what you are doing.\n\n### frappe.db.exists\n\n`frappe.db.exists(doctype, name)`\n\nReturns true if a document record exists.\n\nPass doctype and docname:\n\n```python\nfrappe.db.exists(\"User\", \"jane@example.org\", cache=True)\n```\n\nPass a dict of filters including the `\"doctype\"` key:\n\n```python\nfrappe.db.exists({\"doctype\": \"User\", \"full_name\": \"Jane Doe\"})\n```\n\nPass the doctype and a dict of filters:\n\n```python\nfrappe.db.exists(\"User\", {\"full_name\": \"Jane Doe\"})\n```\n\n### frappe.db.count\n\n`frappe.db.count(doctype, filters)`\n\nReturns number of records for a given `doctype` and `filters`.\n\n```python\n# total number of Task records\nfrappe.db.count('Task')\n\n# total number of Open tasks\nfrappe.db.count('Task', {'status': 'Open'})\n```", "content_type": "mixed", "has_code": true, "token_count": 372}
{"chunk_id": "06_python_api__api__database__004", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/database", "title": "Database", "section_heading": "frappe.db.delete", "content": "## frappe.db.delete\n\n`frappe.db.delete(doctype, filters)`\n\nDelete `doctype` records that match `filters`. This runs a DML command, which means it can be rolled back. If no filters specified, all the records of the doctype are deleted.\n\n```python\nfrappe.db.delete(\"Route History\", {\n    \"modified\": (\"<=\", last_record_to_keep[0].modified),\n    \"user\": user\n})\n\nfrappe.db.delete(\"Error Log\")\nfrappe.db.delete(\"__Test Table\")\n```\n\nYou may pass the doctype name or an internal table name. Conventionally, internal tables in Frappe are prefixed with `__`. The API follows this. The above commands run an unconditional `DELETE` query over tables **tabError Log** and **\\_\\_Test Table**.\n\n### frappe.db.truncate\n\n`frappe.db.truncate(doctype)`\n\nTruncate a table in the database. This runs a DDL command `TRUNCATE TABLE`, a commit is triggered before the statement is executed. This action cannot be rolled back. You may want to use this for clearing out log tables periodically.\n\n```python\nfrappe.db.truncate(\"Error Log\")\nfrappe.db.truncate(\"__Test Table\")\n```\n\nThe above commands run a `TRUNCATE` query over tables **tabError Log** and **\\_\\_Test Table**.\n\n### frappe.db.commit\n\n`frappe.db.commit()`\n\nCommits current transaction. Calls SQL `COMMIT`.\n\n> In most cases you don't need to commit manually. Refer Frappe's [Database transaction model](#database-transaction-model) below.\n\n### frappe.db.savepoint\n\n`frappe.db.savepoint(save_point)`\n\nCreate a named savepoint to which you can later roll back to.", "content_type": "mixed", "has_code": true, "token_count": 374}
{"chunk_id": "06_python_api__api__database__005", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/database", "title": "Database", "section_heading": "frappe.db.rollback", "content": "## frappe.db.rollback\n\n`frappe.db.rollback()`\n\nRollbacks current transaction. Calls SQL `ROLLBACK`.\n\n> Frappe will automatically run `frappe.db.rollback()` if an exception is thrown during a Web Request of type `POST` or `PUT`. Use this if you have to rollback early in a transaction.\n\n`frappe.db.rollback(save_point=\"save_point_name\")`\n\nRollback to a specific savepoint instead rolling back full transactions. This rollback won't undo changes done to filesytem and any other rollback watchers.\n\n### frappe.db.sql\n\n`frappe.db.sql(query, values, as_dict)`\n\nExecute an arbitrary SQL query. This may be useful for complex server side reports with join statements, adjusting the database to new features, etc.\n\nExample:\n\n```python\nvalues = {'company': 'Frappe Technologies Inc'}\ndata = frappe.db.sql(\"\"\"\n    SELECT\n        acc.account_number\n        gl.debit\n        gl.credit\n    FROM `tabGL Entry` gl\n        LEFT JOIN `tabAccount` acc\n        ON gl.account = acc.name\n    WHERE gl.company = %(company)s\n\"\"\", values=values, as_dict=0)\n```\n\n> Avoid using this method as it will bypass validations and integrity checks. It's always better to use [frappe.get\\_doc](https://frappeframework.com/docs/v14/user/en/api/document#frappeget_doc), [frappe.db.get\\_list](#frappedbget_list), etc., if possible.\n\n### frappe.db.multisql\n\n`frappe.db.multisql({'mariadb': mariadb_query, 'postgres': postgres_query})`\n\nExecute the suitable SQL statement for any supported database engine.", "content_type": "mixed", "has_code": true, "token_count": 366}
{"chunk_id": "06_python_api__api__database__006", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/database", "title": "Database", "section_heading": "frappe.db.rename\\_table", "content": "## frappe.db.rename\\_table\n\n`frappe.db.rename_table(old_name, new_name)`\n\nExecutes a query to change table name. Specify the DocType or internal table's name directly to rename the table.\n\nExample:\n\n```python\nfrappe.db.rename_table(\"__internal_cache\", \"__temporary_cache\")\nfrappe.db.rename_table(\"todo\", \"ToDo\")\n```\n\nThe second example should be used only if you understand the ramifications of it.\n\n> Don't use this to rename DocType tables. Use `frappe.rename_doc` for that instead\n\n### frappe.db.describe\n\n`frappe.db.describe(doctype)`\n\nReturns a tuple of the table description for given DocType.\n\n### frappe.db.change\\_column\\_type\n\n`frappe.db.change_column_type(doctype, column, new_type)`\n\nChanges the type of column for specified DocType.\n\n### frappe.db.add\\_index\n\n`frappe.db.add_index(doctype, fields, index_name)`\n\nCreates indexes for doctypes for the specified fields.\n\n> Note: if you want an index on a TEXT or a BLOB field, you must specify a fixed length to do that.\n\nExample:\n\n```python\nfrappe.db.add_index(\"Notes\", [\"id(10)\", \"content(500)\"], index_name)\n```\n\n### frappe.db.add\\_unique\n\n`frappe.db.add_unique(doctype, fields, constraint_name=None)`\n\nCreates unique constraint for doctypes for the specified fields.\n\nExample:\n\n```python\nfrappe.db.add_unique(\"DoctypeName\",[\"field1\",\"field2\"])\n```", "content_type": "mixed", "has_code": true, "token_count": 327}
{"chunk_id": "06_python_api__api__database__007", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/database", "title": "Database", "section_heading": "Database transaction hooks", "content": "## Database transaction hooks\n\nFrappe provides hooks for running callbacks before/after transaction commands like commit/rollback are issued. These hooks are useful for:\n\n* Rolling back changes that are done outside of the database if the transaction is rolled back\n* Flushing changes outside of the database only if the transaction is committed.\n\nThese hooks are :\n\n* `frappe.db.before_commit.add(func: Callable)`\n* `frappe.db.after_commit.add(func: Callable)`\n* `frappe.db.before_rollback.add(func: Callable)`\n* `frappe.db.after_rollback.add(func: Callable)`\n\nExample usage:\n\n```python\ndef create_file(self):\n    self.write_file()\n    # This ensures rollback if DB transaction is rolledback\n    frappe.db.after_rollback.add(self.rollback_file)\n\ndef rollback_file(self):\n    self.delete_file()\n```\n\n### Database transaction model\n\nFrappe's database abstractions implement a sane transaction model by default. So in most cases, you won't have to deal with SQL transactions manually. A broad description of this model is described below:\n\n### Web requests\n\n* While performing `POST` or `PUT`, if any writes were made to the database, they are committed at end of the successful request.\n* AJAX calls made using `frappe.call` are `POST` by default unless changed.\n* `GET` requests do not cause an implicit commit.\n* Any **uncaught** exception during handling of request will rollback the transaction.\n\n### Background/scheduled Jobs\n\n* Calling a function as background or scheduled job will commit the transaction after successful completion.\n* Any **uncaught** exception will cause rollback of the transaction.\n\n### Patches\n\n* Successful completion of the patch's `execute` function will commit the transaction automatically.\n* Any **uncaught** exception will cause rollback of the transaction.", "content_type": "mixed", "has_code": true, "token_count": 448}
{"chunk_id": "06_python_api__api__database__008", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/database", "title": "Database", "section_heading": "Unit tests", "content": "## Unit tests\n\n* Transaction is committed after running one test module. Test module means any python test file like `test_core.py`.\n* Transaction is also committed after finishing all tests.\n* Any **uncaught** exception will exit the test runner, hence won't commit.\n\n> Note: If you're catching exceptions anywhere, then database abstraction does not know that something has gone wrong hence you're responsible for the correct rollback of the transaction.", "content_type": "prose", "has_code": false, "token_count": 114}
{"chunk_id": "06_python_api__api__jinja__001", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/jinja", "title": "Jinja", "section_heading": "frappe.format", "content": "## frappe.format\n\nThese are the whitelisted methods that frappe provides to use them in Jinja\nTemplates.\n\n### frappe.format\n\n`frappe.format(value, df, doc)`\n\nFormats a raw value (stored in database) to a user presentable format.\nFor example, convert 2019-09-08 to 08-09-2019\n\nUsage\n\n```python\n\n09-08-2019\n```\n\n### frappe.format\\_date\n\n`frappe.format_date(date_string)`\n\nFormats date into a human readable long format.\n\nUsage\n\n```python\n\nSeptember 8, 2019\n```\n\n### frappe.get\\_url\n\n`frappe.get_url()`\n\nReturns the site url\n\nUsage\n\n```python\n\nhttps://frappe.io\n```\n\n### frappe.get\\_doc\n\n`frappe.get_doc(doctype, name)`\n\nReturns a document by its name.\n\nUsage\n\n```python\n {% set doc = frappe.get_doc('Task', 'TASK00002') %}\n  - \n\n Buy Eggs - Open\n```\n\n### frappe.get\\_all\n\n`frappe.get_all(doctype, filters, fields, order_by, start, page_length, pluck)`\n\nReturns a list of all records of a DocType. Only returns the document `name`s if the `fields` argument is not given.\n\nSignature\n\n```python\nfrappe.get_all(doctype, filters, fields, order_by, start, page_length)\n```\n\nUsage\n\n```python\n {% set tasks = frappe.get_all('Task', filters={'status': 'Open'}, fields=['title', 'due_date'], order_by='due_date asc') %}\n {% for task in tasks %}\n \n### \n\nDue Date: \n\n {% endfor %}\n\n### Redesign Website\n\nDue Date: September 8, 2019\n\n### Add meta tags on websites\n\nDue Date: September 22, 2019\n```\n\n### frappe.get\\_list\n\n`frappe.get_list(doctype, filters, fields, order_by, start, page_length)`\n\nSimilar to `frappe.get_all` but will filter records for the current session user\nbased on permissions.\n\n### frappe.db.get\\_value\n\n`frappe.db.get_value(doctype, name, fieldname)`\n\nReturns a single field value (or a list of values) from a document.\n\nUsage\n\n```python\n {% set company_abbreviation = frappe.db.get_value('Company', 'TennisMart', 'abbr') %}\n \n \n\n {% set title, description = frappe.db.get_value('Task', 'TASK00002', ['title', 'description']) %}\n ### \n\nTM\n```\n\n### frappe.db.get\\\\_single\\\\_value\n\n`frappe.db.get_single_value(doctype, fieldname)`\n\nReturns a field value from a Single DocType.\n\nUsage\n\n```python\n {% set timezone = frappe.db.get_single_value('System Settings', 'time_zone') %}\n \n \n\n Asia/Kolkata\n```\n\n### frappe.get\\\\_system\\\\_settings\n\n`frappe.get_system_settings(fieldname)`\n\nReturns a field value from System Settings.\n\nUsage\n\n```python\n {% if frappe.get_system_settings('country') == 'India' %}\n Pay via Razorpay\n {% else %}\n Pay via PayPal\n {% endif %}\n\nPay via Razorpay\n```\n\n### frappe.get\\_meta\n\n`frappe.get_meta(doctype)`\n\nReturns a doctype meta. It contains information like fields, title\\\\_field,\nimage\\_field, etc.\n\nUsage\n\n```python\n {% set meta = frappe.get_meta('Task') %}\n Task has  fields.\n {% if meta.get_field('status') %}\n It also has a Status field.\n {% endif %}\n \n\n Task has 18 fields. It also has a Status field.\n```\n\n### frappe.get\\_fullname\n\n`frappe.get_fullname(user_email)`\n\nReturns the fullname of the user email passed. If user is not passed, assumes\ncurrent logged in user.\n\nUsage\n\n```python\nThe fullname of faris@erpnext.com is \nThe current logged in user is \n\nThe fullname of faris@erpnext.com is Faris Ansari\nThe current logged in user is John Doe\n```", "content_type": "mixed", "has_code": true, "token_count": 796}
{"chunk_id": "06_python_api__api__jinja__002", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/jinja", "title": "Jinja", "section_heading": "frappe.format", "content": "## frappe.format\n\n### frappe.render\\_template\n\n`frappe.render_template(template_name, context)`\n\nRender a jinja template string or file with context.\n\nUsage\n\n```python\n \n\n \n', {'foo': 'bar'}) }}\n\nbar\n```\n\n### frappe.\\_\n\n`frappe._(string)` or `_(string)`\n\nUsage\n\n```python\n\n\u0907\u0938 \u0924\u093e\u0930 \u0915\u093e \u0905\u0928\u0941\u0935\u093e\u0926 \u0939\u094b\u0928\u093e \u091a\u093e\u0939\u093f\u090f\n```\n\n### frappe.session.user\n\nReturns the current session user\n\n### frappe.session.csrf\\_token\n\nReturns the current session's CSRF token\n\n### frappe.form\\_dict\n\nIf the template is being evaluated in a web request, `frappe.form_dict` is a\ndict of query parameters, else it is `None`.\n\n### frappe.lang\n\nCurrent language used by the translation function. Two letter, lowercase code.", "content_type": "mixed", "has_code": true, "token_count": 170}
{"chunk_id": "06_python_api__python-api__routing-and-rendering__001", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/routing-and-rendering", "title": "Routing And Rendering", "section_heading": "Request pre-processing", "content": "## Request pre-processing\n\nThe user of a web application can visit different URLs like `/about`, `/posts` or `/api/resources`. Each request is handled based on the following request types.\n\n1. API requests that start with `/api` are handled by [rest API handler](https://github.com/frappe/frappe/blob/develop/frappe/api.py#L16).\n2. File downloads like backups (`/backups`), public files (`/files`), and private files (`/private/files`) are handled separately to respond with a downloadable file.\n3. Web page requests like `/about`, `/posts` are handled by the website router. This is explained further on this page.\n\nLearn more about [API requests](/framework/v14/user/en/api/rest) and [Static Files](/framework/v14/user/en/basics/static-assets) in detail.\n\n### Request pre-processing\n\nA few things happen before the routing rules are triggered. These include preprocessing the request initializing the recorder and the rate limiter.\n\n### Path Resolver\n\nOnce the request reaches to website router from `app.py` it is passed through the path resolver.\n\nPath resolver does the following operations:\n\n### Redirect Resolution\n\nPath resolver tries to resolve any possible redirect for an incoming request path. Path resolver gets redirect rules for [`website_redirects` hook](/framework/v14/user/en/python-api/hooks#website-redirects) and route redirects from website settings.\n\n### Route Resolution\n\nIf there are no redirects for incoming requests path resolver tries to resolve the route to get the final endpoint based on rules from [website\\\\_routing\\\\_rules hook](https://frappeframework.com/docs/v14/user/en/python-api/hooks#website-route-rules) and dynamic route set in documents of DocType with `has_web_view` enabled.\n\n### Renderer Selection\n\nOnce the final endpoint is obtained it is passed through all available [Page Renderers](#page-renderer) to check which page renderer can render the given path. A first page renderer to return `True` for `can_render` request will be used to render the path.", "content_type": "prose", "has_code": false, "token_count": 500}
{"chunk_id": "06_python_api__python-api__routing-and-rendering__002", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/routing-and-rendering", "title": "Routing And Rendering", "section_heading": "Page Renderer", "content": "## Page Renderer\n\nA page renderer takes care of rendering or responding with a page for a given endpoint. A page renderer is implemented using a python class. A page renderer class needs to have two methods i.e., `can_render` and `render`.\n\nPath resolver calls `can_render` to check if a renderer instance can render a particular path.\nOnce a renderer returns `True` from `can_render`, it will be that renderer class's responsibility to render the path.\n\n### Example page renderer class\n\n```python\nfrom frappe.website.page_renderers.base_renderer import BaseRenderer\n\nclass PageRenderer(BaseRenderer):\n def can_render(self):\n return True\n\n def render(self):\n response_html = \"Response\"\n return self.build_response(response_html)\n```\n\nFollowing are the standard page renderers which handle all the generic types of web pages.", "content_type": "mixed", "has_code": true, "token_count": 206}
{"chunk_id": "06_python_api__python-api__routing-and-rendering__003", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/routing-and-rendering", "title": "Routing And Rendering", "section_heading": "StaticPage", "content": "## StaticPage\n\nUsing StaticPage you can serve PDFs, images, etc., from the `www` folder of any app installed on the site. Any file that is **not** one of the following types `html`, `md`, `js`, `xml`, `css`, `txt` or `py` is considered to be a static file.\nThe preferred way of serving static files would be to add them to the `public` folder of your frappe app. That way it will be served by NGINX directly leveraging compression and caching while also reducing latency.\n\n### TemplatePage\n\nThe TemplatePage looks up the `www` folder in all apps, if it is an HTML or markdown file, it is returned, in case it is a folder, the `index.html` or `index.md` file in the folder is returned.\n\n### WebformPage\n\nThe WebformPage tries to render web form in the Web Form list if the request path matches with any of the available Web Form's routes.\n\n### DocumentPage\n\nThe DocumentPage tries to render a document template if it is available in `/templates` folder of the DocType. The template file name should be the same as the DocType name. Example: If you want to add a document template for User doctype, the `templates` folder of User DocType should have `user.html`. The folder structure will look like `doctype/user/templates/user.html`\n\n### ListPage\n\nIf a DocType has a list template in `/templates` folder of the DocType, the ListPage will render it. Please check [Blog Post templates folder](https://github.com/frappe/frappe/tree/develop/frappe/website/doctype/blog_post/templates) for implementation reference.\n\n### PrintPage\n\nThe PrintPage renders a print view for a document. It uses [standard print format](https://github.com/frappe/frappe/blob/develop/frappe/templates/print_formats/standard.html) unless a different print format is set for a DocType via `default_print_format`.\n\n### NotFoundPage\n\nThe NotFoundPage renders a standard not found page and responds with `404` status code.\n\n### NotPermittedPage\n\nThe NotPermittedPage renders standard permission denied page with `403` status code.", "content_type": "prose", "has_code": false, "token_count": 499}
{"chunk_id": "06_python_api__python-api__routing-and-rendering__004", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/routing-and-rendering", "title": "Routing And Rendering", "section_heading": "Adding a custom page renderer", "content": "## Adding a custom page renderer\n\nIf you have any other requirements which are not handled by Standard Page renderers a custom page renderer can be added via `page_renderer` [hook]\n\n```python\n# in hooks.py of your custom app\n\npage_renderer = \"path.to.your.custom_page_renderer.CustomPage\"\n```\n\nA Page renderer class needs to have two methods i.e., `can_render` and `render`\n\nPath resolver calls `can_render` to check if a renderer instance can render a particular path.\nOnce a renderer returns `True` from can\\_render, it will be that renderer class's responsibility to render the path.\n\n**Note:** Custom page renderers get priority and it's `can_render` method will be called before [Standard Page Renderers](#page-renderer).\n\n**Example:**\n\n```python\nfrom frappe.website.utils import build_response\nfrom frappe.website.page_renderers.base_renderer import BaseRenderer\n\nclass CustomPage(BaseRenderer):\n def can_render(self):\n return True\n\n def render(self):\n response_html = \"Custom Response\"\n return self.build_response(response_html)\n```\n\n**Note:** You can also extend Standard Page Renderers to override or to use some standard functionalities.", "content_type": "mixed", "has_code": true, "token_count": 286}
{"chunk_id": "06_python_api__python-api__language__001", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/language", "title": "Language", "section_heading": "Form Dict: \\_lang", "content": "## Form Dict: \\_lang\n\nHere, let's take a look into how language in Frappe is resolved, and how you may\nbe able to use them in your Frappe apps or scripts.\n\nThe language for your session depends on the value of `frappe.lang`. This is\nresolved in the following order:\n\n1. Form Dict > \\_lang\n2. Cookie > preferred\\*language \\*[Guest User only]\\_\n3. Request Header > Accept-Language \\_[Guest User only]\\_\n4. User document > language\n5. System Settings > language\n\n### Form Dict: \\_lang\n\nThe Form Dict's `_lang` parameter has the highest priority. Setting this will\nupdate all translatable components in given request. Frappe uses this mechanism\nin certain places to handle Email Templates and Print views.\n\n### Cookie: preferred\\_language\n\nAlthough, it may not be practical to pass a `?_lang=ru` in every request. If you\nwant persistent yet temporary language setting, you can set the\n`preferred_language` key in cookies. Frappe utilizes this for the website\nlanguage switcher. This method may be used to persist language\nbased on the client.\n\n> Only considered for Guest Users. Ignored for logged in users.", "content_type": "prose", "has_code": false, "token_count": 275}
{"chunk_id": "06_python_api__python-api__language__002", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/language", "title": "Language", "section_heading": "Request Header: Accept-Language", "content": "## Request Header: Accept-Language\n\nAnother relatively cleaner, and standard way to manage languages is using the\n`Accept-Language` header. If the previous two methods aren't set, Frappe starts\nresolving this header's values, which have an ordered set of a range of\nacceptable languages by the client. You can check out [the Mozilla\nDocs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language)\non this topic for more clarity perhaps.\n\n> Only considered for Guest Users. Ignored for logged in users.\n\n### User & System Settings\n\nThe User document has a `language` field that sets the session language for said\nuser. This setting persists across devices, clients. This allows a particular\nuser to view the website, and Desk in a language of their choice. Say for\ninstance, a user sets their language as \"Russian\" on a \"French\" site, when they\nlogin, the site would be translated to Russian automatically.\n\nThe `language` field in the System Settings sets the language for the entire\nsite. It has the lowest priority and is the fallback language for all sessions.", "content_type": "prose", "has_code": false, "token_count": 270}
{"chunk_id": "06_python_api__api__utils__001", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/utils", "title": "Utils", "section_heading": "now", "content": "## now\n\nFrappe Framework comes with various utility functions to handle common operations for managing site-specific DateTime management, date and currency formatting, PDF generation, and much more.\n\nThese utility methods can be imported from the `frappe.utils` module (and its nested modules like `frappe.utils.logger` and `frappe.utils.data`) in any Python file of your Frappe App. This list is not at all exhaustive, you can take a peek at the Framework codebase to see what's available.\n\n### now\n\n`now()`\n\nReturns the current datetime in the format **yyyy-mm-dd hh:mm:ss**\n\n```python\nfrom frappe.utils import now\n\nnow() # '2021-05-25 06:38:52.242515'\n```\n\n### getdate\n\n`getdate(string_date=None)`\n\nConverts `string_date` (yyyy-mm-dd) to `datetime.date` object. If no input is provided, current date is returned. Throws an exception if `string_date` is an invalid date string.\n\n```python\nfrom frappe.utils import getdate\n\ngetdate() # datetime.date(2021, 5, 25)\ngetdate('2000-03-18') # datetime.date(2000, 3, 18)\n```\n\n### today\n\n`today()`\n\nReturns current date in the format **yyyy-mm-dd**.\n\n```python\nfrom frappe.utils import today\n\ntoday() # '2021-05-25'\n```", "content_type": "mixed", "has_code": true, "token_count": 290}
{"chunk_id": "06_python_api__api__utils__002", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/utils", "title": "Utils", "section_heading": "add\\\\_to\\\\_date", "content": "## add\\\\_to\\\\_date\n\n`add_to_date(date, years=0, months=0, weeks=0, days=0, hours=0, minutes=0, seconds=0, as_string=False, as_datetime=False)`\n\n```python\n`date`: A string representation or `datetime` object, uses the current `datetime` if `None` is passed\n`as_string`: Return as string\n`as_datetime`: If `as_string` is True and `as_datetime` is also True, returns a `datetime` string otherwise just the `date` string.\n```\n\nThis function can be quite handy for doing date/datetime deltas, for instance, adding or substracting certain number of days from a particular date/datetime.\n\n```python\nfrom datetime import datetime # from python std library\nfrom frappe.utils import add_to_date\n\ntoday = datetime.now().strftime('%Y-%m-%d')\nprint(today) # '2021-05-21'\n\nafter_10_days = add_to_date(datetime.now(), days=10, as_string=True)\nprint(after_10_days) # '2021-05-31'\n\nadd_to_date(datetime.now(), months=2) # datetime.datetime(2021, 7, 21, 15, 31, 18, 119999)\nadd_to_date(datetime.now(), days=10, as_string=True, as_datetime=True) # '2021-05-31 15:30:23.757661'\nadd_to_date(None, years=6) # datetime.datetime(2027, 5, 21, 15, 32, 31, 652089)\n```\n\n### pretty\\_date\n\n`pretty_date(iso_datetime)`\n\nTakes an ISO time and returns a string representing how long ago the date represents. Very common in communication applications like instant messengers.\n\n```python\nfrom frappe.utils import pretty_date, now, add_to_date\n\npretty_date(now()) # 'just now'\n\n# Some example outputs:\n\n# 1 hour ago\n# 20 minutes ago\n# 1 week ago\n# 5 years ago\n```\n\n### format\\_duration\n\n`format_duration(seconds, hide_days=False)`\n\nConverts the given duration value in seconds (float) to duration format.\n\n```python\nfrom frappe.utils import format_duration\n\nformat_duration(50) # '50s'\nformat_duration(10000) # '2h 46m 40s'\nformat_duration(1000000) # '11d 13h 46m 40s'\n\n# Convert days to hours\nformat_duration(1000000, hide_days=True) # '277h 46m 40s'\n```", "content_type": "mixed", "has_code": true, "token_count": 480}
{"chunk_id": "06_python_api__api__utils__003", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/utils", "title": "Utils", "section_heading": "comma\\_and", "content": "## comma\\_and\n\n`comma_and(some_list, add_quotes=True)`\n\nGiven a list or tuple `some_list`, returns a string of the format `1st item, 2nd item, .... and last item`. This function uses `frappe._`, so you don't have to worry about the translations for the word `and`. If `add_quotes` is `False`, returns the items without quotes, with quotes otherwise. If the type of `some_list` passed as an argument is something other than a list or tuple, it (`some_list`) is returned as it is.\n\n```python\nfrom frappe.utils import comma_and\n\ncomma_and([1, 2, 3]) # \"'1', '2' and '3'\"\ncomma_and(['Apple', 'Ball', 'Cat'], add_quotes=False) # 'Apple, Ball and Cat'\ncomma_and('abcd') # 'abcd'\n```\n\n> There is also a `comma_or` function which is similar to `comma_and` except the separator, which is `or` in the case of `comma_or`.\n\n### money\\\\_in\\\\_words\n\n`money_in_words(number, main_currency=None, fraction_currency=None)`\n\n```python\n`number`: A floating point money amount\n`main_currency`: Uses this as the main currency. If not given, tries to fetch from default settings or uses `INR` if not found there.\n```\n\nThis function returns string in words with currency and fraction currency.\n\n```python\nfrom frappe.utils import money_in_words\n\nmoney_in_words(900) # 'INR Nine Hundred and Fifty Paisa only.'\nmoney_in_words(900.50) # 'INR Nine Hundred and Fifty Paisa only.'\nmoney_in_words(900.50, 'USD') # 'USD Nine Hundred and Fifty Centavo only.'\nmoney_in_words(900.50, 'USD', 'Cents') # 'USD Nine Hundred and Fifty Cents only.'\n```", "content_type": "mixed", "has_code": true, "token_count": 377}
{"chunk_id": "06_python_api__api__utils__004", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/utils", "title": "Utils", "section_heading": "validate\\\\_json\\\\_string", "content": "## validate\\\\_json\\\\_string\n\n`validate_json_string(string)`\n\nRaises `frappe.ValidationError` if the given `string` is a valid JSON (JavaScript Object Notation) string. You can use a `try-except` block to handle a call to this function as shown the code snippet below.\n\n```python\nimport frappe\nfrom frappe.utils import validate_json_string\n\n# No Exception thrown\nvalidate_json_string('[]')\nvalidate_json_string('[{}]')\nvalidate_json_string('[{\"player\": \"one\", \"score\": 199}]')\n\ntry:\n # Throws frappe.ValidationError\n validate_json_string('invalid json')\nexcept frappe.ValidationError:\n print('Not a valid JSON string')\n```\n\n### random\\_string\n\n`random_string(length)`\n\nThis function generates a random string containing `length` number of characters. This can be useful for cryptographic or secret generation for some cases.\n\n```python\nfrom frappe.utils import random_string\n\nrandom_string(40) # 'mcrLCrlvkUdkaOe8m5xMI8IwDB8lszwJsWtZFveQ'\nrandom_string(6) # 'htrB4L'\nrandom_string(6) #'HNRirG'\n```\n\n### unique\n\n`unique(seq)`\n\n`seq`: An iterable / Sequence\n\nThis function returns a list of elements of the given sequence after removing the duplicates. Also, preserves the order, unlike: `list(set(seq))`.\n\n```python\nfrom frappe.utils import unique\n\nunique([1, 2, 3, 1, 1, 1]) # [1, 2, 3]\nunique('abcda') # ['a', 'b', 'c', 'd']\nunique(('Apple', 'Apple', 'Banana', 'Apple')) # ['Apple', 'Banana']\n```", "content_type": "mixed", "has_code": true, "token_count": 349}
{"chunk_id": "06_python_api__api__utils__005", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/utils", "title": "Utils", "section_heading": "get\\_pdf", "content": "## get\\_pdf\n\n`get_pdf(html, options=None, output=None)`\n\n```python\n`html`: HTML string to render\n`options`: An optional `dict` for configuration\n`output`: A optional `PdfFileWriter` object.\n```\n\nThis function uses `pdfkit` and `pyPDF2` modules to generate PDF files from HTML. If `output` is provided, appends the generated pages to this object and returns it, otherwise returns a `byte` stream of the PDF.\n\nFor instance, generating and returning a PDF as response to a web request:\n\n```python\nimport frappe\nfrom frappe.utils.pdf import get_pdf\n\n@frappe.whitelist(allow_guest=True)\ndef generate_invoice():\n cart = [{\n 'Samsung Galaxy S20': 10,\n 'iPhone 13': 80\n }]\n\n html = 'Invoice from Star Electronics e-Store!\n======================================\n\n'\n\n # Add items to PDF HTML\n html += ''\n for item, qty in cart.items():\n html += f'2. {item} - {qty}\n'\n html += '\n'\n\n # Attaching PDF to response\n frappe.local.response.filename = 'invoice.pdf'\n frappe.local.response.filecontent = get_pdf(html)\n frappe.local.response.type = 'pdf'\n```", "content_type": "mixed", "has_code": true, "token_count": 259}
{"chunk_id": "06_python_api__api__utils__006", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/utils", "title": "Utils", "section_heading": "get\\_abbr", "content": "## get\\_abbr\n\n`get_abbr(string, max_len=2)`\n\nReturns an abbrivated (initials only) version of the given `string` with a maximum of `max_len` letters. It is extensively used in Frappe Framework and ERPNext to generate thumbnail or placeholder images.\n\n```python\nfrom frappe.utils import get_abbr\n\nget_abbr('Gavin') # 'G'\nget_abbr('Coca Cola Company') # 'CC'\nget_abbr('Mohammad Hussain Nagaria', max_len=3) # 'MHN'\n```\n\n### validate\\_url\n\n`validate_url(txt, throw=False, valid_schemes=None)`\n\n```python\n`txt`: A string to check validity\n`throw`: Weather to throw an exception if `txt` does not represent a valid URL, `False` by default\n`valid_schemes`: A string or an iterable (list, tuple or set). If provided, checks the given URL's scheme against this.\n```\n\nThis utility function can be used to check if a string represents a valid URL address.\n\n```python\nfrom frappe.utils import validate_url\n\nvalidate_url('google') # False\nvalidate_url('https://google.com') # True\nvalidate_url('https://google.com', throw=True) # throws ValidationError\n```", "content_type": "mixed", "has_code": true, "token_count": 261}
{"chunk_id": "06_python_api__api__utils__007", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/utils", "title": "Utils", "section_heading": "validate\\\\_email\\\\_address", "content": "## validate\\\\_email\\\\_address\n\n`validate_email_address(email_str, throw=False)`\n\nReturns a string containing the email address or comma-separated list of valid email addresses present in the given `email_str`. If `throw` is `True`, `frappe.InvalidEmailAddressError` is thrown in case of no valid email address in present in the given string else an empty string is returned.\n\n```python\nfrom frappe.utils import validate_email_address\n\n# Single valid email address\nvalidate_email_address('rushabh@erpnext.com') # 'rushabh@erpnext.com'\nvalidate_email_address('other text, rushabh@erpnext.com, some other text') # 'rushabh@erpnext.com'\n\n# Multiple valid email address\nvalidate_email_address(\n 'some text, rushabh@erpnext.com, some other text, faris@erpnext.com, yet another no-emailic phrase.'\n) # 'rushabh@erpnext.com, faris@erpnext.com'\n\n# Invalid email address\nvalidate_email_address('some other text') # ''\n```", "content_type": "mixed", "has_code": true, "token_count": 227}
{"chunk_id": "06_python_api__api__utils__008", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/utils", "title": "Utils", "section_heading": "validate\\\\_phone\\\\_number", "content": "## validate\\\\_phone\\\\_number\n\n`validate_phone_number(phone_number, throw=False)`\n\nReturns `True` if `phone_number` (string) is a valid phone number. If `phone_number` is invalid and `throw` is `True`, `frappe.InvalidPhoneNumberError` is thrown.\n\n```python\nfrom frappe.utils import validate_phone_number\n\n# Valid phone numbers\nvalidate_phone_number('753858375') # True\nvalidate_phone_number('+91-75385837') # True\n\n# Invalid phone numbers\nvalidate_phone_number('invalid') # False\nvalidate_phone_number('87345%%', throw=True) # InvalidPhoneNumberError\n```\n\n### frappe.cache()\n\n`cache()`\n\nReturns the redis connection, which is an instance of class `RedisWrapper` which is inherited from the `redis.Redis` class. You can use this connection to use the Redis cache to store/retrieve key-value pairs.\n\n```python\nimport frappe\n\ncache = frappe.cache()\n\ncache.set('name', 'frappe') # True\ncache.get('name') # b'frappe'\n```", "content_type": "mixed", "has_code": true, "token_count": 228}
{"chunk_id": "06_python_api__api__utils__009", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/utils", "title": "Utils", "section_heading": "frappe.sendmail()", "content": "## frappe.sendmail()\n\n`sendmail(recipients=[], sender=\"\", subject=\"No Subject\", message=\"No Message\", as_markdown=False, template=None, args=None, **kwargs)`\n\n```python\n`recipients`: List of recipients\n`sender`: Email sender. Default is current user or default outgoing account\n`subject`: Email Subject\n`message`: (or `content`) Email Content\n`as_markdown`: Convert content markdown to HTML\n`template`: Name of html template (jinja) from templates/emails folder\n`args`: Arguments for rendering the template\n```\n\nFor most cases, the above arguments are sufficient but there are many other keyword arguments that can be passed to this function. To see all the keyword arguments, please have a look the implementation of this function (`frappe/__init__.py`).\n\nThis function can be used to send email using user's default **Email Account** or global default **Email Account**.\n\n```python\nimport frappe\n\nrecipients = [\n 'gavin@erpnext.com',\n 'hussain@erpnext.com'\n]\n\nfrappe.sendmail(\n recipients=recipients,\n subject=frappe._('Birthday Reminder'),\n template='birthday_reminder',\n args=dict(\n reminder_text=reminder_text,\n birthday_persons=birthday_persons,\n message=message,\n ),\n header=_('Birthday Reminder \ud83c\udf82')\n)\n```\n\nSample Jinja template file:\n\n```python\n {% for person in birthday_persons %}\n {% if person.image %}\n ![]( \"\")\n {% endif %}\n {% endfor %}\n \n\n```", "content_type": "mixed", "has_code": true, "token_count": 339}
{"chunk_id": "06_python_api__api__utils__010", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/utils", "title": "Utils", "section_heading": "Attaching Files", "content": "## Attaching Files\n\nYou can easily attach files to your email by passing a list of attachments to the `sendmail` function:\n\n```python\nfrappe.sendmail(\n [\"faris@frappe.io\", \"hussain@frappe.io\"],\n message=\"## hello, *bro*\"\n attachments=[{\"file_url\": \"/files/hello.png\"}],\n as_markdown=True\n)\n```\n\nNotice how attachments are a list of dictionaries having a key `file_url`. You can find this `file_url` in a `File` document's `file_url` field.\n\n### filelock\n\nFile lock can be used to synchronize processes to avoid race conditions.\n\nExample: Writing to a file can cause race condition if multiple writers are trying to write to a file.\nSo we create a named lock so processes can see the lock and wait until it's avialable for writing.\n\n```python\nfrom frappe.utils.synchronization import filelock\n\ndef update_important_config(config, file):\n with filelock(\"config_name\"):\n json.dumps(config, file)\n```", "content_type": "mixed", "has_code": true, "token_count": 224}
{"chunk_id": "06_python_api__python-api__response__001", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/response", "title": "Response", "section_heading": "", "content": "Here, let's take a look into how responses are built in Frappe, and how you may\nbe able to use them in your Frappe apps or scripts.\n\nIf you have already gone through the [Router\nDocumentation](/framework/v14/user/en/python-api/routing-and-rendering), you might've noticed the\n`build_response` function that Frappe internally utilizes to build responses\ndepending on the type of the content. The logic that defines this behaviour is a\npart of the module\n[frappe.utils.response](https://github.com/frappe/frappe/blob/develop/frappe/utils/response.py),\nof which `build_response` is the meat and potatoes.\n\n```python\ndef build_response(response_type=None):\n if \"docs\" in frappe.local.response and not frappe.local.response.docs:\n del frappe.local.response[\"docs\"]\n\n response_type_map = {\n \"csv\": as_csv,\n \"txt\": as_txt,\n \"download\": as_raw,\n \"json\": as_json,\n \"pdf\": as_pdf,\n \"page\": as_page,\n \"redirect\": redirect,\n \"binary\": as_binary,\n }\n\n return response_type_map[frappe.response.get(\"type\") or response_type]()\n```\n\nThe above snippet represents the current implementation of `build_response`\nwhich maps different functions that act as handlers for different content types.\nLet's take a deeper look into the response handler for the **\"download\"**\n`response_type` in Frappe v13.\n\n```python\ndef as_raw():\n response = Response()\n response.mimetype = (\n frappe.response.get(\"content_type\")\n or mimetypes.guess_type(frappe.response[\"filename\"])[0]\n or \"application/unknown\"\n )\n response.headers[\"Content-Disposition\"] = (\n f'{frappe.response.get(\"display_content_as\", \"attachment\")};'\n f' filename=\"{frappe.response[\"filename\"].replace(\" \", \"_\")}\"'\n ).encode(\"utf-8\")\n response.data = frappe.response[\"filecontent\"]\n return response\n```\n\nDepending on the value of the `Content-Disposition` header, the browser\nreceiving the response may behave differently. If unset, the value defaults to\n**\"attachment\"**.\n\nIf `frappe.response.display_content_as` is set to **\"inline\"**, it indicates\nthat the content is expected to be displayed inline in the browser, that is, as\na Web page or as part of a Web page, while **\"attachment\"** means the contents\nare to be downloaded and saved locally.\n\nTo create an API endpoint that would directly download the file you require, you\ncould craft something like the following to download the file directly.\n\n```python\n@frappe.whitelist()\ndef download(name):\n file = frappe.get_doc(\"File\", name)\n frappe.response.filename = file.file_name\n frappe.response.filecontent = file.get_content()\n frappe.response.type = \"download\"\n frappe.response.display_content_as = \"attachment\"\n```", "content_type": "mixed", "has_code": true, "token_count": 651}
{"chunk_id": "06_python_api__python-api__search__001", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/search", "title": "Search", "section_heading": "The `FullTextSearch` class", "content": "## The `FullTextSearch` class\n\nSearching in Frappe is managed by the [Search](https://github.com/frappe/frappe/blob/develop/frappe/search) module. It is a wrapper for [Whoosh](https://pypi.org/project/Whoosh/) a full text search library written in Python.\n\nYou can extend the `FullTextSearch` class to create a search class for a specific requirement. For example the [`WebsiteSearch`](https://github.com/frappe/frappe/blob/develop/frappe/search/website_search.py) is a wrapper for indexing public facing web pages and exposing a search.\n\n### The `FullTextSearch` class\n\nEach FullTextSearch (FTS) instance holds a Schema defined by the class itself. That means, a specific FTS implementation will have it's specific schema. You can create a new implementation if you wish to index with a different schema. Along with this the `FTS` class has other controllers to facilitate creating, updating and querying the index.", "content_type": "prose", "has_code": false, "token_count": 229}
{"chunk_id": "06_python_api__python-api__search__002", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/search", "title": "Search", "section_heading": "Extending the FTS class", "content": "## Extending the FTS class\n\nWhen initializing a FTS based class, you need to provide an index name. On instantiation, the following params are initialized\n\n* `index_name`: name of the index provided.\n* `index_path`: path of the index in the sites folder\n* `schema`: return by the `get_schema` function\n* `id`: id used to recognize the document in the index\n\nOnce instantiated you can run the `build` function. It gets all the documents from `get_items_to_index`, the documents are a list of `frappe._dict` (frappe dicts) conforming to the defined schema. These documents are then added to the index and written to the file.\n\nYou can search the index using the `search` method of the FTS class. These functions are documented in the API reference [here](/framework/v14/user/en/api/full-text-search).\n\nAn example implementation for blog will look like the following:\n\n```python\nclass BlogWrapper(FullTextSearch):\n # Default Schema\n # def get_schema(self):\n # return Schema(name=ID(stored=True), content=TEXT(stored=True))\n\n # def get_id(self):\n # return \"name\"\n\n def get_items_to_index(self):\n docs = []\n for blog_name in get_all_blogs():\n docs.append(get_document_to_index(blog_name))\n return docs\n\n def get_document_to_index(self, name):\n blog = frappe.get_doc(\"Blog Post\", name)\n return frappe._dict(name=name, content=blog.content)\n\n def parse_result(self, result):\n return result[\"name\"]\n```\n\n* `get_items_to_index`: Get all routes to be indexed, this includes the static pages in www/ and routes from published documents\n* `get_document_to_index`: Render a page and parse it using BeautifulSoup\n* `parse_result`: all the search results are parsed using this function", "content_type": "mixed", "has_code": true, "token_count": 417}
{"chunk_id": "06_python_api__python-api__hooks__001", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "How does hooks work?", "content": "## How does hooks work?\n\nHooks allow you to \"hook\" into functionality and events of core parts of the Frappe Framework. This page documents all of the hooks provided by the framework.\n\n> Jump to list of all [available hooks](#list-of-available-hooks) in Frappe.\n\n### How does hooks work?\n\nHooks are places in the core code that allow an app to override the standard implementation or extend it. Hooks are defined in **hooks.py** of your app.\n\nLet's learn by example. Add the following hooks in your app's **hooks.py**.\n\n```python\ntest_string = \"value\"\ntest_list = [\"value\"]\ntest_dict = {\n    \"key\": \"value\"\n}\n```\n\nNow, open the python console by running the command `bench --site sitename console` and run the following lines:\n\n```python\n\u276f bench --site sitename console\nApps in this namespace:\nfrappe, frappe_docs\n\nIn [1]: frappe.get_hooks(\"test_string\")\nOut[1]: [\"value\"]\n\nIn [2]: frappe.get_hooks(\"test_dict\")\nOut[2]: {\"key\": [\"value\"]}\n\nIn [3]: frappe.get_hooks(\"test_list\")\nOut[3]: [\"value\"]\n```\n\nWhen you call `frappe.get_hooks`, it will convert all the values in a list. This means that if the hook is defined in multiple apps, the values will be collected from those apps. This is what enables the cascading nature of hooks.\n\nNow, the hook value can be consumed in different ways. For example, for including JS assets using `app_include_js`, all of the values are included. But for overriding whitelisted method, the last value in the list is used.\n\nSo the implementation of the hook is totally dependent on how the author of the feature intended it to be used.", "content_type": "mixed", "has_code": true, "token_count": 392}
{"chunk_id": "06_python_api__python-api__hooks__002", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "How are conflicting hooks resolved?", "content": "## How are conflicting hooks resolved?\n\nHooks are resolved using \"last writer wins\" strategy. Last installed app on site will have highest priority over others.\n\n* When the hook overrides existing behaviour like overriding a class then only overrides from last app will work.\n* When the hook extends behaviour then extensions will be applied in order of installation on the site.\n\n> If you need to change this order you can do so by going to \"Installed Applications\" page and clicking on \"Update Hooks Resolution Order\"\n\n### App Meta Data\n\nThese are automatically generated when you create a new app. Most of the time you don't need to change anything here.\n\n1. `app_name` - slugified name of the app\n2. `app_title` - presentable app name\n3. `app_publisher`\n4. `app_description`\n5. `app_version`\n6. `app_icon`\n7. `app_color`\n\n### Javascript / CSS Assets\n\nThe following hooks allow you to inject static JS and CSS assets in various parts of your site.\n\n### Desk\n\nThese hooks allow you to inject JS / CSS in `desk.html` which renders the [Desk](/framework/v14/user/en/desk).\n\n```python\n# injected in desk.html\napp_include_js = \"assets/js/app.min.js\"\napp_include_css = \"assets/js/app.min.css\"\n\n# All of the above support a list of paths too\napp_include_js = [\"assets/js/app1.min.js\", \"assets/js/app2.min.js\"]\n```\n\n### Portal\n\nThese hooks allow you to inject JS / CSS in `web.html` which renders the [Portal](/framework/v14/user/en/portal-pages).\n\n```python\n# injected in the web.html\nweb_include_js = \"assets/js/app-web.min.js\"\nweb_include_css = \"assets/js/app-web.min.css\"\n# All of the above support a list of paths too\nweb_include_js = [\"assets/js/web1.min.js\", \"assets/js/web2.min.js\"]\n```\n\n### Web Form\n\nThese hooks allow you to add inject static JS and CSS assets in `web_form.html` which is used to render Web Forms. These will work only for Standard Web Forms.\n\n```python\nwebform_include_js = {\"ToDo\": \"public/js/custom_todo.js\"}\nwebform_include_css = {\"ToDo\": \"public/css/custom_todo.css\"}\n```\n\n> For user created Web Forms, you can directly write the script in the form > itself.", "content_type": "mixed", "has_code": true, "token_count": 521}
{"chunk_id": "06_python_api__python-api__hooks__003", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "Page", "content": "## Page\n\nThese hooks allow you to inject JS assets in Standard Desk Pages.\n\n```python\npage_js = {\"page_name\" : \"public/js/file.js\"}\n```\n\nFor e.g., Background Jobs is a standard page that is part of Core module in Frappe Framework. To add custom behaviour in that page you can add a JS file in your custom app `custom_app/public/js/custom_background_jobs.js` and add the following line in your hooks file.\n\n**custom\\_app/hooks.py**\n\n```python\npage_js = {\"background_jobs\": \"public/js/custom_background_jobs.js\"}\n```\n\n### Sounds\n\nFrappe ships with a set of audio notifications for events like a success action, document submission, error, etc. You can add your own sounds using the `sounds` hook.\n\n**app/hooks.py**\n\n```python\nsounds = [\n    {\"name\": \"ping\", \"src\": \"/assets/app/sounds/ping.mp3\", \"volume\": 0.2}\n]\n```\n\nYou can play your added sound using the client utility method:\n\n```python\nfrappe.utils.play_sound(\"ping\")\n```", "content_type": "mixed", "has_code": true, "token_count": 231}
{"chunk_id": "06_python_api__python-api__hooks__004", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "Install Hooks", "content": "## Install Hooks\n\nThese hooks allow you to run code before and after installation of your app. For example, [ERPNext](https://github.com/frappe/erpnext) has these [defined](https://github.com/frappe/erpnext/blob/ecfa6344c02b18455637455742202c7fadf1b35d/erpnext/hooks.py#L42-L43).\n\n```python\n# python module path\nbefore_install = \"app.setup.install.before_install\"\nafter_install = \"app.setup.install.after_install\"\nafter_sync = \"app.setup.install.after_sync\"\n```\n\n**app/setup/install.py**\n\n```python\n# will run before app is installed on site\ndef before_install():\n    pass\n\n# will run after app is installed on site\ndef after_install():\n    pass\n\n# will run after app fixtures are synced\ndef after_sync():\n    pass\n```\n\n### Uninstall Hooks\n\nThese hooks allow you to run code before and after uninstallation of your app.\n\n**app/hooks.py**\n\n```python\nbefore_uninstall = \"app.setup.uninstall.before_uninstall\"\nafter_uninstall = \"app.setup.uninstall.after_uninstall\"\n```\n\n**app/setup/uninstall.py**\n\n```python\n# will run before app is uninstalled from site\ndef before_uninstall():\n    pass\n\n# will run after app is uninstalled from site\ndef after_uninstall():\n    pass\n```\n\n### Migrate Hooks\n\nThese hooks allow you to run code before and after a migration is run on your site via the command `bench --site sitename migrate`.\n\n**app/hooks.py**\n\n```python\nbefore_migrate = \"app.migrate.before_migrate\"\nafter_migrate = \"app.migrate.after_migrate\"\n```\n\n**app/migrate.py**\n\n```python\ndef after_migrate():\n    # run code after site migration\n    pass\n```\n\n### Test Hooks\n\nThis hook allows you to run code before tests are run on a site. You can use this hook to add seed data to your database which will be available to your tests.\n\n**app/hooks.py**\n\n```python\nbefore_tests = \"app.tests.before_tests\"\n```\n\n**app/migrate.py**\n\n```python\ndef before_tests():\n    # add seed data to the database\n    pass\n```", "content_type": "mixed", "has_code": true, "token_count": 473}
{"chunk_id": "06_python_api__python-api__hooks__005", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "File Hooks", "content": "## File Hooks\n\nThese hooks allows you to change the implementation of handling user uploaded files.\n\n**app/hooks.py**\n\n```python\nbefore_write_file = \"app.overrides.file.before_write\"\nwrite_file = \"app.overrides.file.write_file\"\ndelete_file_data_content = \"app.overrides.file.delete_file\"\n```\n\n**app/overrides/file.py**\n\n```python\n# will run before file is written to disk\ndef before_write():\n    pass\n\n# will override the implementation of writing file to disk\n# can be used to upload files to a CDN instead of writing\n# the file to disk\ndef write_file():\n    pass\n\n# will override the implementation of deleting file from disk\n# can be used to delete uploaded files from a CDN instead of\n# deleting file from disk\ndef delete_file():\n    pass\n```\n\n### Email Hooks\n\nThese hooks allows you to change the default email module implementation of sending emails and setting default sender address.\n\n**app/hooks.py**\n\n```python\noverride_email_send = \"app.overrides.email.send\"\nget_sender_details = \"app.overrides.email.get_sender_details\"\n```\n\nBy default frappe uses the currently logged in users name and id as sender details on all emails. This can be overriden with `get_sender_details` hook. And if you want to extend the email modules functionality by using a thirdy party server or app for sending emails then you can use `override_email_send` hook. This hook will send all the email information (sender, recipient, content(mime)) to a function in custom\\_app.\n\n**app/overrides/email.py**\n\n```python\n# will be edited as \"John Doe <johndoe@gmail.com>\"\ndef get_sender_details():\n    return \"John Doe\", \"johndoe@gmail.com\"\n\n# self - EmailQueue object refrence for updating status\ndef send(self, sender, recipient, msg):\n    # smtp or http request\n    self.update_status(\"Sending\")\n```\n\n> Note: You'll have to handle the status change of email queue in your custom app depending on the webhook response you get from your mail provider/server", "content_type": "mixed", "has_code": true, "token_count": 484}
{"chunk_id": "06_python_api__python-api__hooks__006", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "Extend Bootinfo", "content": "## Extend Bootinfo\n\nAfter a successful login, the Desk is injected with a dictionary of global values called `bootinfo`. The `bootinfo` is available as a global object in Javascript as `frappe.boot`.\n\nThe `bootinfo` dict contains a lot of values including:\n\n* System defaults\n* Notification status\n* Permissions\n* User settings\n* Language and timezone info\n\nYou can add global values that makes sense for your app via the `extend_bootinfo` hook.\n\n```python\n# python module path\nextend_bootinfo = \"app.boot.boot_session\"\n```\n\nThe method is called with one argument `bootinfo`, on which you can directly add/update values.\n\n**app/boot.py**\n\n```python\ndef boot_session(bootinfo):\n bootinfo.my_global_key = \"my_global_value\"\n```\n\nNow, you can access the value anywhere in your client side code.\n\n```python\nconsole.log(frappe.boot.my_global_key)\n```", "content_type": "mixed", "has_code": true, "token_count": 211}
{"chunk_id": "06_python_api__python-api__hooks__007", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "Website Context", "content": "## Website Context\n\nWhen a Portal Page is rendered, a dictionary is built with all of the possible variables that the page might need to render. This dict is also known as `context`. You can use these hooks to add or modify values in this dict.\n\n**app/hooks.py**\n\n```python\nwebsite_context = {\n    \"favicon\": \"/assets/app/image/favicon.png\"\n}\nupdate_website_context = \"app.overrides.website_context\"\n```\n\nThe `website_context` hook is a simple dict of key value pairs. Use this hook for simple value overrides.\n\nYou can use the `update_website_context` hook for more complex scenarios as it allows you to manipulate the context dict in a python method. The method is called with one argument, which is the `context` dict. You can either modify the context directly by mutating it or return a dict that will be merged with `context`.\n\n**app/overrides.py**\n\n```python\ndef website_context(context):\n context.my_key = \"my_value\"\n```", "content_type": "mixed", "has_code": true, "token_count": 232}
{"chunk_id": "06_python_api__python-api__hooks__008", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "Website Controller Context", "content": "## Website Controller Context\n\nFrappe ships with standard web pages like `/404` and `/about`. If you want to extend the controller context for these pages you can use the `extend_website_page_controller_context` hook.\n\n**app/hooks.py**\n\n```python\nextend_website_page_controller_context = {\n    \"frappe.www.404\": \"app.pages.context_404\"\n}\n```\n\nThe above hook configuration will allow you to extend the context of the 404 page so that you can add your own keys or modify existing ones.\n\n**app/pages.py**\n\n```python\ndef context_404(context):\n    # context of the 404 page\n    context.my_key = \"my_value\"\n```\n\n### Website Clear Cache\n\nFrappe Framework caches a lot of static web pages for fast subsequent rendering. If you have created web pages that use cached values, and you want to invalidate the cache, this hook is place to do it.\n\n**app/hooks.py**\n\n```python\nwebsite_clear_cache = \"app.overrides.clear_website_cache\"\n```\n\nThe method is called with one argument `path`. `path` is set when cache is being cleared for one route, and is `None` when cache is cleared for all routes. You need to handle this case if your cache is page specific.\n\n**app/overrides.py**\n\n```python\ndef clear_website_cache(path=None):\n    if path:\n        # clear page related cache\n    else:\n        # clear all cache\n```", "content_type": "mixed", "has_code": true, "token_count": 324}
{"chunk_id": "06_python_api__python-api__hooks__009", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "Website Redirects", "content": "## Website Redirects\n\nWebsite Redirects allow you to define redirects from one route to another. Frappe will generate a 304 Redirect response when the source URL is requested and redirect to the target URL. You can redirect plain URLs or you can use regex to match your URLs.\n\n**app/hooks.py**\n\n```python\nwebsite_redirects = [\n    {\"source\": \"/compare\", \"target\": \"/comparison\"},\n    {\"source\": \"/docs(/.*)?\", \"target\": \"https://docs.tennismart.com/\\1\"},\n    {\"source\": r'/items/item\\?item_name=(.*)', \"target\": '/items/\\1', match_with_query_string=True},\n]\n```\n\nThe above configuration will result in following redirects:\n\n* `/compare` to `/comparison`\n* `/docs/getting-started` to `https://docs.tennismart.com/getting-started`\n* `/docs/help` to `https://docs.tennismart.com/help`\n* `/items/item?item_name=racket` to `https://docs.tennismart.com/items/racket`", "content_type": "mixed", "has_code": true, "token_count": 215}
{"chunk_id": "06_python_api__python-api__hooks__010", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "Website Route Rules", "content": "## Website Route Rules\n\nWebsite Route Rules allow you to map URLs to custom controllers. This is commonly used to generate clean URLs for pages.\n\nLet's say you want to have `/projects` route to display list of projects. This can be done by creating a `projects.html` and `projects.py` in `www` folder.\n\nYou also want to have `/project/<name>` route to show a project page where name is the dynamic. To do this you can use the `website_route_rules` hook.\n\n**app/hooks.py**\n\n```python\nwebsite_route_rules = [\n    {\"from_route\": \"/projects/<name>\", \"to_route\": \"app/projects/project\"},\n]\n```\n\nNow, you can create your controller files in `app/projects` folder.\n\n**app/projects/project.py**\n\n```python\ndef get_context(context):\n    project_name = frappe.form_dict.name\n    project = frappe.get_doc(\"Project\", project_name)\n    context.project = project\n```\n\n**app/projects/project.html**\n\n```python\n<h1></h1>\n<p></p>\n```\n\n### Website 404\n\nFrappe renders a default `/404` route when a page is not found. You can change this using the `website_catch_all` hook.\n\n**app/hooks.py**\n\n```python\nwebsite_catch_all = \"not_found\"\n```\n\nThe above configuration will render `/not_found` when a 404 is occurred. It is upto you to implement the template `www/not_found.html` and controller `www/not_found.py`.", "content_type": "mixed", "has_code": true, "token_count": 322}
{"chunk_id": "06_python_api__python-api__hooks__011", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "Default Homepage", "content": "## Default Homepage\n\nHomepage is the page which is rendered when you visit the root URL (`/`) of your site. There are multiple ways to configure what page is rendered as the default homepage.\n\nBy default, the homepage is `index`. So, frappe will try to render `index.html` from `www` folder. This can be overridden using the `homepage` hook.\n\n**app/hooks.py**\n\n```python\nhomepage = \"homepage\"\n```\n\nThe above configuration will load the `www/homepage.html` as the default homepage.\n\nYou can also have role based homepage by using the `role_home_page` hook.\n\n**app/hooks.py**\n\n```python\nrole_home_page = {\n    \"Customer\": \"orders\",\n    \"Supplier\": \"bills\"\n}\n```\n\nThe above configuration will make `/orders` the default homepage for users with the **Customer** role and `/bills` for users with the **Supplier** role.\n\nYou can have even more control over the logic by using the `get_website_user_home_page` hook.\n\n**app/hooks.py**\n\n```python\nget_website_user_home_page = \"app.website.get_home_page\"\n```\n\n**app/website.py**\n\n```python\ndef get_home_page(user):\n    if is_projects_user(user):\n        return \"projects\"\n    if is_partner(user):\n        return \"partner-dashboard\"\n    return \"index\"\n```\n\n> If all of these hooks are defined, the `get_website_user_home_page` will have > higher priority over the others, and `role_home_page` will have higher > priority over `homepage`.", "content_type": "mixed", "has_code": true, "token_count": 344}
{"chunk_id": "06_python_api__python-api__hooks__012", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "Portal Sidebar", "content": "## Portal Sidebar\n\nSome Portal views are shown with a sidebar with links to quickly jump to pages. These sidebar items can be customized via hooks.\n\n**app/hooks.py**\n\n```python\nportal_menu_items = [\n    {\"title\": \"Dashboard\", \"route\": \"/dashboard\", \"role\": \"Customer\"},\n    {\"title\": \"Orders\", \"route\": \"/orders\", \"role\": \"Customer\"},\n]\n```\n\nThe above configuration will add two sidebar links for users with the role Customer.\n\n![Portal Sidebar](/files/hooks-portal-menu-items.png)\n\nThese sidebar items are hardcoded in your app so they are not customizable from Desk. For e.g., if you want to hide a sidebar link temporarily you will have to make changes in your code.\n\nThere is another hook called `standard_portal_menu_items` which allows you to do that. The sidebar links set in `standard_portal_menu_items` hook will be synced with the database.\n\n**app/hooks.py**\n\n```python\nstandard_portal_menu_items = [\n    {\"title\": \"Dashboard\", \"route\": \"/dashboard\", \"role\": \"Website Manager\"},\n    {\"title\": \"Orders\", \"route\": \"/orders\", \"role\": \"Website Manager\"},\n]\n```\n\nThe above configuration will sync sidebar items to the Portal Settings which can later be edited by any System User.\n\n![Portal Settings](/files/hooks-standard-portal-menu-items.png)", "content_type": "mixed", "has_code": true, "token_count": 312}
{"chunk_id": "06_python_api__python-api__hooks__013", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "Brand HTML", "content": "## Brand HTML\n\nThis hook allows you to customize the brand logo in the navbar of your website.\n\n**app/hooks.py**\n\n```python\nbrand_html = '<div><img src=\"tennismart.png\"/> TennisMart</div>'\n```\n\nIf the `brand_html` is defined, it will override the default brand html in the navbar. It is not recommended to use hooks to change your brand logo, unless you want to version control it, otherwise you can use Website Settings to change it.\n\n### Base Template\n\nWhen a web page is rendered, it extends `templates/base.html` by default. You can override the base template by overriding the `base_template` hook.\n\n**app/hooks.py**\n\n```python\nbase_template = \"app/templates/my_custom_base.html\"\n```\n\nYou can also customize base templates based on routes. For e.g., if you want to use a different base template for all the routes that start with `docs/*` then you can use the `base_template_map` hook. The key must be a regex that matches the route. All other routes will fallback to the default base template.\n\n**app/hooks.py**\n\n```python\nbase_template_map = {\n    r\"docs.*\": \"app/templates/doc_template.html\"\n}\n```\n\n### Integrations\n\nThese hooks allow you to customize behaviour of 3rd-party integrations in Frappe.", "content_type": "mixed", "has_code": true, "token_count": 301}
{"chunk_id": "06_python_api__python-api__hooks__014", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "Braintree Success Page", "content": "## Braintree Success Page\n\nThis hook allows you to override the default redirect URL on successful payment of Braintree transaction.\n\n**app/hooks.py**\n\n```python\nbraintree_success_page = \"app.integrations.braintree_success_page\"\n```\n\nThe method is called with one argument `data` which has the meta data of the payment.\n\n**app/integrations.py**\n\n```python\ndef braintree_success_page(data):\n    # data.reference_doctype\n    # data.reference_docname\n    return \"/thank-you\"\n```\n\n### Calendars\n\nThe calendar hook is a list of doctype names which are shown as menu items for quick navigation from the Calendar page in Desk.\n\n**app/hooks.py**\n\n```python\ncalendars = [\"Appointment\"]\n```\n\n![Event Menu Shortcuts](/files/hooks-event-menu-shortcuts.png)\n\n### Clear Cache\n\nThis hook allows you to clear your app specific cache values when the global cache is being cleared by frappe.\n\n**app/hooks.py**\n\n```python\nclear_cache = \"app.cache.clear_cache\"\n```\n\nYou can use this hook to clear your app specific cache. The method is called without any arguments.\n\n**app/cache.py**\n\n```python\ndef clear_cache():\n    frappe.cache().hdel(\"app_specific_cache\")\n```\n\n### Default Mail Footer\n\nIf you want to set the default footer of all the emails that are sent out by Frappe, you can use the `default_mail_footer` hook.\n\n**app/hooks.py**\n\n```python\ndefault_mail_footer = \"\"\"\n <div>\n Sent via <a href=\"https://tennismart.com\" target=\"_blank\">TennisMart</a>\n</div>\n\"\"\"\n```\n\nNow, all the emails will have **Sent via TennisMart** in the footer.", "content_type": "mixed", "has_code": true, "token_count": 379}
{"chunk_id": "06_python_api__python-api__hooks__015", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "Session Hooks", "content": "## Session Hooks\n\nThese hooks are triggered over the login lifecycle of a user. `on_login` is triggered immediately after a successful login, `on_session_creation` is triggered after the session is setup, `on_logout` is triggered after the user logs out.\n\n**app/hooks.py**\n\n```python\non_login = \"app.overrides.successful_login\"\non_session_creation = \"app.overrides.allocate_free_credits\"\non_logout = \"app.overrides.clear_user_cache\"\n```\n\nThe method will be called with one argument `login_manager`.\n\n**app/overrides.py**\n\n```python\ndef allocate_free_credits(login_manager):\n    # allocate free credits to frappe.session.user\n    pass\n```\n\n### Auth Hooks\n\nThese hooks are triggered during request authentication. Custom headers, Authorization headers can be validated here, user is verified and mapped to the request using `frappe.set_user()`. Use `frappe.request` and `frappe.*` to validate request and map user.\n\n**app/hooks.py**\n\n```python\nauth_hooks = [\"app.overrides.validate_custom_jwt\"]\n```\n\nThe method will be called during request authentication.\n\n**app/overrides.py**\n\n```python\ndef validate_custom_jwt():\n    # validate jwt from header, verify signature, set user from jwt.\n    pass\n```\n\nUse this method to check for incoming request header, verify the header and map the user to the request. If header verification fails DO NOT throw error to continue with other hooks. Unverified request is treated as \"Guest\" request by default. You may use third party server, shared database or any alternative of choice to verify and map request and user.", "content_type": "mixed", "has_code": true, "token_count": 388}
{"chunk_id": "06_python_api__python-api__hooks__016", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "Fixtures", "content": "## Fixtures\n\nFixtures are database records that are synced using JSON files when you install and update your site.\n\nLet's say you want to create a set of categories in the database whenever you install your app. To do that, create the set of categories in your local site, and add the doctype name in the `fixtures` hook.\n\n```python\nfixtures = [\n    # export all records from the Category table\n    \"Category\"\n]\n```\n\nNow, run the following command:\n\n```python\nbench --site sitename export-fixtures\n```\n\nThis command will create a JSON file for each doctype which will contain the data to generate list of records. You can test this by creating a new site and by installing your app on that site.\n\nYou can also add conditions for exporting records.\n\n```python\nfixtures = [\n    # export all records from the Category table\n    \"Category\",\n    # export only those records that match the filters from the Role table\n    {\"dt\": \"Role\", \"filters\": [[\"role_name\", \"like\", \"Admin%\"]]},\n]\n```\n\nSome fields are for internal use only. They will be set and kept up-to-date by the system automatically. These will not get exported: `modified_by`, `creation`, `owner`, `idx`, `lft` and `rgt`. For child table records, the following fields will not get exported: `docstatus`, `doctype`, `modified` and `name`.", "content_type": "mixed", "has_code": true, "token_count": 323}
{"chunk_id": "06_python_api__python-api__hooks__017", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "Modify List Query", "content": "## Modify List Query\n\nYou can customize how list of records are queried for a DocType by adding custom match conditions using the `permission_query_conditions` hook. This match condition must be a valid WHERE clause fragment for an SQL query.\n\n**app/hooks.py**\n\n```python\npermission_query_conditions = {\n    \"ToDo\": \"app.permissions.todo_query\",\n}\n```\n\nThe method is called with a single argument `user` which can be `None`. The method should return a string that is a valid SQL WHERE clause.\n\n**app/permissions.py**\n\n```python\ndef todo_query(user):\n    if not user:\n        user = frappe.session.user\n    # todos that belong to user or assigned by user\n    return \"(`tabToDo`.owner = {user} or `tabToDo`.assigned_by = {user})\".format(user=frappe.db.escape(user))\n```\n\nNow, if you use the `frappe.db.get_list` method, your WHERE clause will be appended to the query.\n\n```python\ntodos = frappe.db.get_list(\"ToDo\", debug=1)\n\n# output\n'''\nselect `tabToDo`.`name`\nfrom `tabToDo`\nwhere ((`tabToDo`.owner = 'john@doe.com' or `tabToDo`.assigned_by = 'john@doe.com'))\norder by `tabToDo`.`modified` DESC\n'''\n```\n\n> This hook will only affect the result of `frappe.db.get_list` method and not > `frappe.db.get_all`.", "content_type": "mixed", "has_code": true, "token_count": 301}
{"chunk_id": "06_python_api__python-api__hooks__018", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "Document Permissions", "content": "## Document Permissions\n\nYou can modify the behaviour of `doc.has_permission` document method for any DocType and add custom permission checking logic using the `has_permission` hook.\n\n**app/hooks.py**\n\n```python\nhas_permission = {\n    \"Event\": \"app.permissions.event_has_permission\",\n}\n```\n\nThe method will be passed the `doc`, `user` and `permission_type` as arguments. It should return `True` or a `False` value. If `None` is returned, it will fallback to default behaviour.\n\n**app/permissions.py**\n\n```python\ndef event_has_permission(doc, user=None, permission_type=None):\n    # when reading a document allow if event is Public\n    if permission_type == \"read\" and doc.event_type == \"Public\":\n        return True\n\n    # when writing a document allow if event owned by user\n    if permission_type == \"write\" and doc.owner == user:\n        return True\n\n    return False\n```", "content_type": "mixed", "has_code": true, "token_count": 218}
{"chunk_id": "06_python_api__python-api__hooks__019", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "Override DocType Class", "content": "## Override DocType Class\n\nYou can override/extend the class for standard doctypes by using the `override_doctype_class` hook.\n\n**app/hooks.py**\n\n```python\noverride_doctype_class = {\n    \"ToDo\": \"app.overrides.todo.CustomToDo\"\n}\n```\n\n**app/overrides/todo.py**\n\n```python\nfrom frappe.desk.doctype.todo.todo import ToDo\n\nclass CustomToDo(ToDo):\n    def on_update(self):\n        self.my_custom_code()\n        super().on_update()\n\n    def my_custom_code(self):\n        pass\n```\n\n> It is recommended that you extend the standard class of the doctype, otherwise > you will have to implement all of the core functionality.\n\n### Override Form Scripts\n\nYou can override/extend [Standard Form Scripts](/framework/v14/user/en/api/form#standard-form-scripts) by using the `doctype_js` hook.\n\n**app/hooks.py**\n\n```python\ndoctype_js = {\n    \"ToDo\": \"public/js/todo.js\",\n}\n```\n\n**app/public/js/todo.js**\n\n```python\nfrappe.ui.form.on(\"Todo\", {\n    refresh: function(frm) {\n        frm.trigger(\"my_custom_code\");\n    },\n    my_custom_code: function(frm){\n        console.log(frm.doc.name)\n    }\n});\n```\n\n> The events/functions defined in `app/public/todo.js` will extend > those in the standard form script of `ToDo` doctype.", "content_type": "mixed", "has_code": true, "token_count": 302}
{"chunk_id": "06_python_api__python-api__hooks__020", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "CRUD Events", "content": "## CRUD Events\n\nYou can hook into various CRUD events of any doctype using the `doc_events` hook.\n\n**app/hooks.py**\n\n```python\ndoc_events = {\n    \"*\": {\n        # will run after any DocType record is inserted into database\n        \"after_insert\": \"app.crud_events.after_insert_all\"\n    },\n    \"ToDo\": {\n        # will run before a ToDo record is inserted into database\n        \"before_insert\": \"app.crud_events.before_insert_todo\",\n    }\n}\n```\n\nThe method will be passed the doc and the method name as arguments.\n\n**app/crud\\_events.py**\n\n```python\ndef after_insert_all(doc, method=None):\n    pass\n\ndef before_insert_todo(doc, method=None):\n    pass\n```\n\n> See [Controller Hooks](/framework/v14/user/en/basics/doctypes/controllers#controller-hooks) > for a list of all available hooks.\n\n### Override Whitelisted Methods\n\nWhitelisted Methods are python methods that are accessible on a REST endpoint and consumed by a client. You can override standard whitelisted methods that are part of the core framework using the `override_whitelisted_methods` hook.\n\n**app/hooks.py**\n\n```python\noverride_whitelisted_methods = {\n    \"frappe.client.get_count\": \"app.whitelisted.custom_get_count\"\n}\n```\n\nThe method should have the same signature as the original method.\n\n**app/whitelisted.py**\n\n```python\ndef custom_get_count(doctype, filters=None, debug=False, cache=False):\n    # your custom implementation of the standard get_count method provided by frappe\n    pass\n```\n\n### Ignore Links on Delete\n\nTo ignore links to specific DocTypes when deleting documents, you can specify them in the `ignore_links_on_delete` hook like so:\n\n**app/hooks.py**\n\n```python\nignore_links_on_delete = [\"Communication\", \"ToDo\"]\n```", "content_type": "mixed", "has_code": true, "token_count": 425}
{"chunk_id": "06_python_api__python-api__hooks__021", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "Form Timeline", "content": "## Form Timeline\n\nThe timeline section of [form view](/framework/v14/user/en/desk#form-view) of a document shows an audit trail of actions performed on that document like views, value changes, comments and related communications, etc.\n\nApart from these standard actions, there might arise a situation where you need to add your own custom actions. You can do this via `additional_timeline_content` hook.\n\n```python\nadditional_timeline_content: {\n    # show in each document's timeline\n    \"*\": [\"app.timeline.all_timeline\"]\n    # only show in ToDo's timeline\n    \"ToDo\": [\"app.timeline.todo_timeline\"]\n}\n```\n\nThe method will be passed the doctype and docname as arguments. You can perform queries and return actions related to that document as a list of dicts as shown in the example. Each dict in the list must have a `creation` value which will be used to sort the item in the timeline.\n\n```python\ndef todo_timeline(doctype, docname):\n    # this method should return a list of dicts\n    return [\n        {\n             # this will be used to sort the content in the timeline\n            \"creation\": \"22-05-2020 18:00:00\",\n            # this JS template will be rendered in the timeline\n            \"template\": \"custom_timeline_template\",\n            # this data will be passed to the template.\n            \"template_data\": {\"key\": \"value\"},\n        },\n        ...\n    ]\n```", "content_type": "mixed", "has_code": true, "token_count": 343}
{"chunk_id": "06_python_api__python-api__hooks__022", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "Scheduler Events", "content": "## Scheduler Events\n\nYou can use Scheduler Events for running tasks periodically in the background using the `scheduler_events` hook.\n\n**app/hooks.py**\n\n```python\nscheduler_events = {\n    \"hourly\": [\n        # will run hourly\n        \"app.scheduled_tasks.update_database_usage\"\n    ],\n}\n```\n\n**app/scheduled\\_tasks.py**\n\n```python\ndef update_database_usage():\n    pass\n```\n\n> After changing any scheduled events in `hooks.py`, you need to run `bench migrate` for changes to take effect.\n\n### Available Events\n\n* `hourly`, `daily`, `weekly`, `monthly`\n\nThese events will trigger every hour, day, week and month respectively.\n\n* `hourly_long`, `daily_long`, `weekly_long`, `monthly_long`\n\nSame as above but these jobs are run in the [long worker](/framework/v14/user/en/basics/directory-structure#worker_long) suitable for long running jobs.\n\n* `all`\n\nThe `all` event is triggered every 60 seconds. This can be configured via the `scheduler_tick_interval` key in `common_site_config.json`\n\n* `cron`\n\nA valid cron string that can be parsed by [croniter](https://pypi.org/project/croniter/).\n\nUsage Examples:\n\n```python\nscheduler_events = {\n    \"daily\": [\n        \"app.scheduled_tasks.manage_recurring_invoices\"\n    ],\n    \"daily_long\": [\n        \"app.scheduled_tasks..take_backups_daily\"\n    ],\n    \"cron\": {\n        \"15 18 * * *\": [\n            \"app.scheduled_tasks..delete_all_barcodes_for_users\"\n        ],\n        \"*/6 * * * *\": [\n            \"app.scheduled_tasks..collect_error_snapshots\"\n        ],\n        \"annual\": [\n            \"app.scheduled_tasks.collect_error_snapshots\"\n        ]\n    }\n}\n```", "content_type": "mixed", "has_code": true, "token_count": 400}
{"chunk_id": "06_python_api__python-api__hooks__023", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "Jinja Customization", "content": "## Jinja Customization\n\nFrappe provides a list of [global utility methods](/framework/v14/user/en/api/jinja) in Jinja templates. To add your own methods and filters you can use the `jinja` hook.\n\n**app/hooks.py**\n\n```python\njinja = {\n    \"methods\": [\n        \"app.jinja.methods\",\n        \"app.utils.get_fullname\"\n    ],\n    \"filters\": [\n        \"app.jinja.filters\",\n        \"app.utils.format_currency\"\n    ]\n}\n```\n\n**app/jinja/methods.py**\n\n```python\ndef sum(a, b):\n    return a + b\n\ndef multiply(a, b):\n    return a * b\n```\n\n> If the path is a module path, all the methods in that module will be added.\n\n**app/utils.py**\n\n```python\ndef get_fullname(user):\n    first_name, last_name = frappe.db.get_value(\"User\", user, [\"first_name\", \"last_name\"])\n    return first_name + \" \" + last_name\n\ndef format_currency(value, currency):\n    return currency + \" \" + str(value)\n```\n\nNow, you can use these utilities in your Jinja templates like so:\n\n```python\n<h1>Hi, </h1>\n<p>Your account balance is </p>\n<p>1 + 2 = </p>\n```", "content_type": "mixed", "has_code": true, "token_count": 253}
{"chunk_id": "06_python_api__python-api__hooks__024", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "Prevent Auto Cancellation of Linked Documents", "content": "## Prevent Auto Cancellation of Linked Documents\n\nTo prevent documents of a specific DocType from being automatically cancelled on the cancellation of any linked documents you can use the `auto_cancel_exempted_doctypes` hook.\n\n**app/hooks.py**\n\n```python\nauto_cancel_exempted_doctypes = [\"Payment Entry\"]\n```\n\nIn the above example, if any document (for e.g Sales Invoice) that is linked with Payment Entry is cancelled, it will skip the auto-cancellation of the linked Payment Entry document.\n\n### Notification configurations\n\nThe notification configuration hook is used to customize the items shown in the Notification dropdown in Desk. It can be configured by the `notification_config` hook.\n\n**app/hooks.py**\n\n```python\nnotification_config = \"app.notification.get_config\"\n```\n\nThe method is called without any arguments.\n\n**app/notification.py**\n\n```python\ndef get_config():\n return {\n        \"for_doctype\": {\n            \"Issue\": {\"status\":\"Open\"},\n            \"Issue\": {\"status\":\"Open\"},\n        },\n        \"for_module_doctypes\": {\n            \"ToDo\": \"To Do\",\n            \"Event\": \"Calendar\",\n            \"Comment\": \"Messages\"\n        },\n        \"for_module\": {\n            \"To Do\": \"frappe.core.notifications.get_things_todo\",\n            \"Calendar\": \"frappe.core.notifications.get_todays_events\",\n            \"Messages\": \"frappe.core.notifications.get_unread_messages\"\n        }\n    }\n```\n\nThe above configuration has three parts:\n\n1. `for_doctype` part of the above configuration marks any \"Issue\" or \"Customer Issue\" as unread if its status is Open\n2. `for_module_doctypes` maps doctypes to module's unread count.\n3. `for_module` maps modules to functions to obtain its unread count. The functions are called without any argument.\n\n### Required Apps\n\nWhen building apps, you might create apps that build on top of other apps. To make sure dependent apps are installed when someone installs your app, you can use the `required_apps` hook.\n\n**app/hooks.py**\n\n```python\nrequired_apps = [\"erpnext\"]\n```\n\nThe above configuration will make sure `erpnext` is installed when someone installs your app.", "content_type": "mixed", "has_code": true, "token_count": 525}
{"chunk_id": "06_python_api__python-api__hooks__025", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "User Data Protection & Privacy", "content": "## User Data Protection & Privacy\n\nUser Data Privacy features like personal data download and personal data deletion come out of the box in Frappe. What constitutes as personal data may be defined by the App publisher in the application's `hooks.py` file as `user_data_fields`.\n\n**app/hooks.py**\n\n```python\nuser_data_fields = [\n    {\"doctype\": \"Access Log\"},\n    {\"doctype\": \"Comment\", \"strict\": True},\n    {\n        \"doctype\": \"Contact\",\n        \"filter_by\": \"email_id\",\n        \"rename\": True,\n    },\n    {\"doctype\": \"Contact Email\", \"filter_by\": \"email_id\"},\n    {\n        \"doctype\": \"File\",\n        \"filter_by\": \"attached_to_name\",\n        \"redact_fields\": [\"file_name\", \"file_url\"],\n    },\n    {\"doctype\": \"Email Unsubscribe\", \"filter_by\": \"email\", \"partial\": True},\n]\n```\n\nDocTypes that have user data should be mapped under this hook using the above format. Upon data deletion or download requests from users, this hook will be utilized to map over the specified DocTypes. The options available to modify documents are:\n\n| Field | Description |\n| --- | --- |\n| `doctype` | DocType that contains user data. |\n| `filter_by` | Docfield to filter the documents by. If unset, defaults to `owner`. |\n| `partial` | If set, all text fields are parsed and user's full name and username references will be redacted. |\n| `redact_fields` | Fields that have to be redacted. If unspecified, it considers partial data redaction from all text fields. |\n| `rename` | If document name contains user data, set this field to rename document to anonymize it. |\n| `strict` | If set to True, any user data will be redacted from all documents of current DocType. If unset, it defaults to False which means it only filters through documents in which user is the owner. |\n\n> Note: Personal Data Download only utilizes the doctype and filter\\_by fields defined in `user_data_fields`\n\nRelated Topics:\n\n1. [Personal Data Deletion](https://docs.erpnext.com/docs/user/manual/en/setting-up/personal-data-deletion)\n2. [Personal Data Download](https://docs.erpnext.com/docs/user/manual/en/setting-up/personal-data-download)", "content_type": "mixed", "has_code": true, "token_count": 524}
{"chunk_id": "06_python_api__python-api__hooks__026", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "Signup Form Template", "content": "## Signup Form Template\n\nIf you want to add additional fields to the signup form you can use this hook. Create a template file which contains the custom signup form. Pass this template to the custom signup hook.\n\n```python\nsignup_form_template = \"school/templates/signup-form.html\"\n```\n\n> Note: If you want custom fields in signup form, it will require additional fields in the user doctype. You will have to add these fields using fixtures. Also you will have to write your own submit handler for this signup form and a function on the server side which will signup the user. This way you can also write validations for the custom fields you add.", "content_type": "mixed", "has_code": true, "token_count": 161}
{"chunk_id": "06_python_api__python-api__hooks__027", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/python-api/hooks", "title": "Hooks", "section_heading": "List of available hooks", "content": "## List of available hooks\n\n| Hook Name | Explanation |\n| --- | --- |\n| `additional_timeline_content` | [Form Timeline](#form-timeline) |\n| `after_install` | [Install Hooks](#install-hooks) |\n| `after_migrate` | [Migrate Hooks](#migrate-hooks) |\n| `after_sync` | [Install Hooks](#install-hooks) |\n| `app_include_css` | [Desk Assets](#desk) |\n| `app_include_js` | [Desk Assets](#desk) |\n| `app_logo_url` | [App Meta Data](#app-meta-data) |\n| `app_title` | [App Meta Data](#app-meta-data) |\n| `auto_cancel_exempted_doctypes` | [Prevent Auto Cancellation](#prevent-auto-cancellation-of-linked-documents) |\n| `base_template_map` | [Base Template](#base-template) |\n| `base_template` | [Base Template](#base-template) |\n| `before_install` | [Install Hooks](#install-hooks) |\n| `before_migrate` | [Migrate Hooks](#migrate-hooks) |\n| `before_tests` | [Test Hooks](#test-hooks) |\n| `before_write_file` | [File Hooks](#file-hooks) |\n| `bot_parsers` | *Deprecated* |\n| `braintree_success_page` | [Braintree Success Page](#braintree-success-page) |\n| `brand_html` | [Brand HTML](#brand-html) |\n| `calendars` | [Calendars](#calendars) |\n| `clear_cache` | [Clear Cache](#clear-cache) |\n| `communication_doctypes` |  |\n| `default_mail_footer` | [Default Mail Footer](#default-mail-footer) |\n| `delete_file_data_content` | [File Hooks](#file-hooks) |\n| `doc_events` | [Document CRUD Events](#crud-events) |\n| `doctype_js` | [Override Form Scripts](#override-form-scripts) |\n| `domains` |  |\n| `dump_report_map` | *Deprecated* |\n| `extend_bootinfo` | [Extend Bootinfo](#extend-bootinfo) |\n| `extend_website_page_controller_context` | [Website Controller Context](#website-controller-context) |\n| `filters_config` |  |\n| `fixtures` | [Fixtures](#fixtures) |\n| `get_site_info` |  |\n| `get_translated_dict` |  |\n| `get_website_user_home_page` | [Default Homepage](#default-homepage) |\n| `has_permission` | [Document Permissions](#document-permissions) |\n| `has_website_permission` |  |\n| `home_page` | [Default Homepage](#default-homepage) |\n| `jenv` | [Jinja Customization](#jinja-customization) |\n| `leaderboards` |  |\n| `look_for_sidebar_json` |  |\n| `make_email_body_message` |  |\n| `notification_config` | [Notification configuration](#notification-configurations) |\n| `on_login` | [Session Hooks](#session-hooks) |\n| `on_logout` | [Session Hooks](#session-hooks) |\n| `on_session_creation` | [Session Hooks](#session-hooks) |\n| `override_doctype_class` | [Override DocType Class](#override-doctype-class) |\n| `override_doctype_dashboards` |  |\n| `override_whitelisted_methods` | [Override Whitelisted Methods](#override-whitelisted-methods) |\n| `ignore_links_on_delete` | [Ignore Links on Delete](#ignore-links-on-delete) |\n| `permission_query_conditions` | [Modify List Query](#modify-list-query) |\n| `portal_menu_items` | [Portal Sidebar](#portal-sidebar) |\n| `required_apps` | [Required Apps](#required-apps) |\n| `role_home_page` | [Default Homepage](#default-homepage) |\n| `scheduler_events` | [Scheduler Events](#scheduler-events) |\n| `setup_wizard_complete` |  |\n| `setup_wizard_exception` |  |\n| `setup_wizard_requires` |  |\n| `setup_wizard_stages` |  |\n| `setup_wizard_success` |  |\n| `signup_form_template` | [Signup Form Template](#signup-form-template) |\n| `sounds` | [Sounds](#sounds) |\n| `standard_portal_menu_items` | [Portal Sidebar](#portal-sidebar) |\n| `standard_queries` |  |\n| `template_apps` |  |\n| `translated_languages_for_website` |  |\n| `translator_url` |  |\n| `treeviews` | DocTypes that use TreeView as the default view (instead of ListView) |\n| `update_website_context` | [Website Context](#website-context) |\n| `user_privacy_documents` | *Deprecated* (Use `user_data_fields` hook) |\n| `user_data_fields` | [User Data Protection & Privacy](#user-data-protection-&-privacy) |\n| `web_include_css` | [Portal Assets](#portal) |\n| `web_include_js` | [Portal Assets](#portal) |\n| `website_catch_all` | [Website 404](#website-404) |\n| `website_clear_cache` | [Website Clear Cache](#website-clear-cache) |\n| `website_context` | [Website Context](#website-context) |\n| `website_generators` | *Deprecated* (Use Has Web View in DocType instead) |\n| `website_redirects` | [Website Redirects](#website-redirects) |\n| `website_route_rules` | [Website Route Rules](#website-route-rules) |\n| `website_user_home_page` | *Deprecated* (Use `homepage` hook) |\n| `welcome_email` |  |\n| `write_file_keys` | *Deprecated* |\n| `write_file` | [File Hooks](#file-hooks) |", "content_type": "prose", "has_code": false, "token_count": 1114}
{"chunk_id": "06_python_api__api__rest__001", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/rest", "title": "Rest", "section_heading": "Authentication", "content": "## Authentication\n\nFrappe framework generates REST API for all of your DocTypes out of the box. You can also run arbitrary python methods using their dotted module path.\n\n### Authentication\n\nThere are two ways to authenticate through Frappe REST API. Token based authentication and password based authentication.\n\n### 1. Token Based Authentication\n\nA token is a pair of API Key and API Secret. To generate these tokens follow these steps:\n\n1. Go to User list and open a user.\n2. Click on the \"Settings\" tab. (skip this step if you don't see tabs)\n3. Expand the API Access section and click on Generate Keys.\n4. You will get a popup with the API Secret. Copy this value and keep it somewhere safe (Password Manager).\n5. You will also see another field \"API Key\" in this section.\n\nThe token is generated by concatenating `api_key` and `api_secret` with a colon `:`. Pass the string `token api_key:api_secret` to the `Authorization` header in the request.\n\n```python\nfetch('http://<base-url>/api/method/frappe.auth.get_logged_user', {\n    headers: {\n        'Authorization': 'token api_key:api_secret'\n    }\n})\n.then(r => r.json())\n.then(r => {\n    console.log(r);\n})\n```\n\n```python\n\u279c curl http://<base-url>/api/method/frappe.auth.get_logged_user -H \"Authorization: token api_key:api_secret\"\n```\n\nEvery request you make with these tokens will be logged against the user you selected in Step 1. This also means that roles will be checked against this user. You can also create a new user just for API calls.", "content_type": "mixed", "has_code": true, "token_count": 375}
{"chunk_id": "06_python_api__api__rest__002", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/rest", "title": "Rest", "section_heading": "2. Password Based Authentication", "content": "## 2. Password Based Authentication\n\nPassword based authentication relies on cookies and session data to maintain authentication in subsequent requests. In most cases, the library you are using to issue REST calls will handle session data, but if it doesn't you should use Token based authentication.\n\n```python\nfetch('http://<base-url>/api/method/login', {\n    method: 'POST',\n    headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n        usr: 'username or email',\n        pwd: 'password'\n    })\n})\n.then(r => r.json())\n.then(r => {\n    console.log(r);\n})\n```\n\n```python\n\u279c curl --cookie-jar snowcookie --request POST \"http://<base-url>/api/method/login\" -H 'Content-Type: application/json' -H 'Accept: application/json' --data-raw \"{ \"usr\" : \"<username>\", \"pwd\": \"<password>\" }\"\n{\"message\":\"Logged In\",\"home_page\":\"/app\",\"full_name\":\"<user:full_name>\",\"dashboard_route\":\"/sites\"}\n\n\u279c curl --cookie snowcookie --request POST \"http://<base-url>/api/method/frappe.auth.get_logged_user\" -H 'Accept: application/json'\n{\"message\":\"<username>\"}\n```\n\n### 3. Access Token\n\nRefer documentation for [How to setup OAuth](/framework/v14/user/en/guides/integration/how_to_set_up_oauth).\n\nUse the generated `access_token` in request header.\n\n```python\nfetch('http://<base-url>/api/method/frappe.auth.get_logged_user', {\n    headers: {\n        'Authorization': 'Bearer access_token'\n    }\n})\n.then(r => r.json())\n.then(r => {\n    console.log(r);\n})\n```", "content_type": "mixed", "has_code": true, "token_count": 378}
{"chunk_id": "06_python_api__api__rest__003", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/rest", "title": "Rest", "section_heading": "Listing Documents", "content": "## Listing Documents\n\nTo get a list of records of a DocType, send a GET request at `/api/resource/:doctype`. By default, it will return 20 records and will only fetch the name of the records. The result for the query can be found under `data` of the payload.\n\nWe'll be using the ToDo DocType to show example responses for the queries below.\n\n```python\nGET /api/resource/:doctype\n```\n\nResponse\n\n```python\n{\n  \"data\":[\n    {\"name\":\"f765eef382\"},\n    {\"name\":\"2a26fa1c64\"},\n    {\"name\":\"f32c68060f\"},\n    {\"name\":\"9065fa9832\"},\n    {\"name\":\"419082fc38\"},\n    {\"name\":\"6234d15099\"},\n    {\"name\":\"62f2181ee0\"},\n    {\"name\":\"a50afbbfaa\"},\n    ...\n  ]\n}\n```\n\nYou can specify which fields to fetch in the `fields` param. It should be a JSON array.\n\n```python\nGET /api/resource/:doctype?fields=[\"field1\", \"field2\"]\n```\n\nResponse\n\n```python\n{\n  \"data\":[\n    {\"description\":\"Business worker talk society. Each try theory prove notice middle. Crime couple trouble guy project hit.\",\"name\":\"f765eef382\"},\n    {\"description\":\"This reveal as look near sister. Car staff bar specific address.\",\"name\":\"2a26fa1c64\"},\n    {\"description\":\"Wear bag some walk. Movie partner new class tough run. Brother Democrat imagine.\",\"name\":\"f32c68060f\"},\n    {\"description\":\"Break laugh apply reveal new now focus heavy. Outside local staff research total. Else point try despite.\",\"name\":\"9065fa9832\"},\n    {\"description\":\"Truth reduce baby artist actually model. Cost phone us others himself wife almost. Language thing wonder share talk. Factor glass significant could window certain yet.\",\"name\":\"419082fc38\"},\n    {\"description\":\"Tv memory understand opportunity window beat physical.\",\"name\":\"6234d15099\"},\n    {\"description\":\"Should floor situation in response sell. Our assume company mean red majority shoulder.\",\"name\":\"62f2181ee0\"},\n    {\"description\":\"Performance seem sign recent. Court form me tonight simple trouble. Address job garden play teach. Happy speech amount offer change then.\",\"name\":\"a50afbbfaa\"},\n    ...\n  ]\n}\n```\n\nYou can filter the records by passing `filters` param. Filters should be an array, where each filter is of the format: `[field, operator, value]`\n\n```python\nGET /api/resource/:doctype?filters=[[\"field1\", \"=\", \"value1\"], [\"field2\", \">\", \"value2\"]]\n```\n\nResponse\n\n```python\n{\n  \"data\":[\n    {\"name\":\"f765eef382\"},\n    {\"name\":\"2a26fa1c64\"},\n    {\"name\":\"f32c68060f\"},\n    {\"name\":\"9065fa9832\"},\n    {\"name\":\"419082fc38\"},\n    {\"name\":\"6234d15099\"},\n    {\"name\":\"62f2181ee0\"},\n    {\"name\":\"a50afbbfaa\"},\n    ...\n  ]\n}\n```\n\n`filters` parameter joins all the specified filters using `AND` SQL operator, if you want `OR` filters you can use the `or_filters` param. Syntax for `or_filters` is same as `filters.\n\nYou can also provide the sort field and order. It should be of the format `fieldname asc` or `fieldname desc`. The space should be URL encoded. In the following line, we're taking fieldname to be `title`.\n\n```python\nGET /api/resource/:doctype?order_by=title%20desc\n```\n\nYou can also page the results by providing the `limit_start` and `limit_page_length` params.\n\n```python\nGET /api/resource/:doctype?limit_start=5&amp;limit_page_length=10\n```\n\nResponse", "content_type": "mixed", "has_code": true, "token_count": 792}
{"chunk_id": "06_python_api__api__rest__004", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/rest", "title": "Rest", "section_heading": "Listing Documents", "content": "## Listing Documents\n\nResponse\n\n```python\n{\n  \"data\": [\n    {\"name\":\"6234d15099\"},\n    {\"name\":\"62f2181ee0\"},\n    {\"name\":\"a50afbbfaa\"},\n    {\"name\":\"aa12a5cf71\"},\n    {\"name\":\"6ac9800d4e\"},\n    {\"name\":\"4bcf8b701c\"},\n    {\"name\":\"aee15f4c20\"},\n    {\"name\":\"6ba753afef\"},\n    ...\n  ]\n}\n```\n\n`limit` is an alias for `limit_page_length` for accessing `/api/resource` in Version 13. This means the following should also return the same payload as the above query.\n\n```python\nGET /api/resource/:doctype?limit_start=5&amp;limit=10\n```\n\nBy default, you will receive the data as `List[dict]`. You can retrieve your data as `List[List]` by passing `as_dict=False`.\n\n```python\nGET /api/resource/:doctype?limit_start=5&amp;limit=5&amp;as_dict=False\n```\n\nResponse\n\n```python\n{\n  \"data\": [\n    [\"6234d15099\"],\n    [\"62f2181ee0\"],\n    [\"a50afbbfaa\"],\n    [\"aa12a5cf71\"],\n    [\"6ac9800d4e\"]\n  ]\n}\n```\n\nTo debug the query built for your reqeusts, you can pass `debug=True` with the request. This returns the executed query and execution time under `exc` of the payload.\n\n```python\nGET /api/resource/:doctype?limit_start=10&amp;limit=5&amp;debug=True\n```\n\nResponse\n\n```python\n{\n  \"data\": [\n    {\"name\":\"4bcf8b701c\"},\n    {\"name\":\"aee15f4c20\"},\n    {\"name\":\"6ba753afef\"},\n    {\"name\":\"f4b7e24abc\"},\n    {\"name\":\"bd9156096c\"}\n  ],\n  \"exc\": \"[\\\"select `tabToDo`.`name`\\\\n\\\\t\\\\t\\\\tfrom `tabToDo`\\\\n\\\\t\\\\t\\\\t\\\\n\\\\t\\\\t\\\\t\\\\n\\\\t\\\\t\\\\t order by `tabToDo`.`modified` DESC\\\\n\\\\t\\\\t\\\\tlimit 5 offset 10\\\", \\\"Execution time: 0.0 sec\\\"]\"\n}\n```", "content_type": "mixed", "has_code": true, "token_count": 378}
{"chunk_id": "06_python_api__api__rest__005", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/rest", "title": "Rest", "section_heading": "CRUD Operations", "content": "## CRUD Operations\n\nFrappe generates REST endpoints for CRUD operations for all DocTypes automatically. Make sure you set the following headers in your requests so that you get proper JSON responses.\n\n```python\n{\n    \"Accept\": \"application/json\",\n    \"Content-Type\": \"application/json\",\n}\n```\n\n### Create\n\nCreate a new document by sending a `POST` request to `/api/resource/:doctype`. Send the document as JSON in the Request Body.\n\n```python\nPOST /api/resource/:doctype\n\n# Body\n{\"description\": \"New ToDo\"}\n```\n\nResponse\n\n```python\n{\n  \"data\": {\n    \"name\": \"af2e2d0e33\",\n    \"owner\": \"Administrator\",\n    \"creation\": \"2019-06-03 14:19:00.281026\",\n    \"modified\": \"2019-06-03 14:19:00.281026\",\n    \"modified_by\": \"Administrator\",\n    \"idx\": 0,\n    \"docstatus\": 0,\n    \"status\": \"Open\",\n    \"priority\": \"Medium\",\n    \"description\": \"New ToDo\",\n    \"doctype\": \"ToDo\"\n  }\n}\n```", "content_type": "mixed", "has_code": true, "token_count": 218}
{"chunk_id": "06_python_api__api__rest__006", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/rest", "title": "Rest", "section_heading": "Read", "content": "## Read\n\nGet a document by sending a `GET` request to `/api/resource/:doctype/:name`.\n\n```python\nGET /api/resource/:doctype/:name\n```\n\nResponse\n\n```python\n{\n  \"data\": {\n    \"name\": \"bf2e760e13\",\n    \"owner\": \"Administrator\",\n    \"creation\": \"2019-06-03 14:19:00.281026\",\n    \"modified\": \"2019-06-03 14:19:00.281026\",\n    \"modified_by\": \"Administrator\",\n    \"idx\": 0,\n    \"docstatus\": 0,\n    \"status\": \"Open\",\n    \"priority\": \"Medium\",\n    \"description\": \"<p>Test description</p>\",\n    \"doctype\": \"ToDo\"\n  }\n}\n```\n\n### Update\n\nUpdate a document by sending a `PUT` request to `/api/resource/:doctype/:name`. You don't need to send the whole document, instead you can just send the fields that you want to update.\n\n```python\nPUT /api/resource/:doctype/:name\n\n# Body\n{\"description\": \"New description\"}\n```\n\nResponse\n\n```python\n{\n  \"data\": {\n    \"name\": \"bf2e760e13\",\n    \"owner\": \"Administrator\",\n    \"creation\": \"2019-06-03 14:19:00.281026\",\n    \"modified\": \"2019-06-03 14:21:00.785117\",\n    \"modified_by\": \"Administrator\",\n    \"idx\": 0,\n    \"docstatus\": 0,\n    \"status\": \"Open\",\n    \"priority\": \"Medium\",\n    \"description\": \"New description\",\n    \"doctype\": \"ToDo\"\n  }\n}\n```\n\n### Delete\n\nDelete a document by sending a `DELETE` request to `/api/resource/:doctype/:name`.\n\n```python\nDELETE /api/resource/:doctype/:name\n```\n\nResponse\n\n```python\n{\"message\": \"ok\"}\n```", "content_type": "mixed", "has_code": true, "token_count": 340}
{"chunk_id": "06_python_api__api__rest__007", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/rest", "title": "Rest", "section_heading": "Remote Method Calls", "content": "## Remote Method Calls\n\nFrappe allows you to trigger arbitrary python methods using the REST API for handling custom logic. These methods must be marked as *whitelisted* to make them accessible via REST.\n\nTo run a whitelisted python method at `frappe.auth.get_logged_user`, send a request to the endpoint `/api/method/frappe.auth.get_logged_user`.\n\n```python\nGET /api/method/frappe.auth.get_logged_user\n```\n\nResponse\n\n```python\n{\n  \"message\": \"john@doe.com\"\n}\n```\n\n* If your method returns some values, you should send a `GET` request.\n* If your method changes the state of the database, use `POST`. After a successful `POST` request, the framework will automatically call `frappe.db.commit()` to commit the changes to the database.\n* A successful response will return a JSON object with a `message` key.\n* An errored response will return a JSON object with `exc` key which contains the stack trace and `exc_type` which contains the thrown Exception.\n* The return value of the method will be converted to a JSON and sent as the response.", "content_type": "mixed", "has_code": true, "token_count": 259}
{"chunk_id": "06_python_api__api__rest__008", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/rest", "title": "Rest", "section_heading": "File Uploads", "content": "## File Uploads\n\nThere is a dedicated method `/api/method/upload_file` that accepts binary file data and uploads it into the system.\n\nHere is the curl command for it:\n\n```python\n\u279c curl -X POST \\\n  http://<base-url>/api/method/upload_file \\\n  -H 'Accept: application/json' \\\n  -H 'Authorization: token xxxx:yyyy' \\\n  -F file=@/path/to/file/file.png\n```\n\nIf you are using client side Javascript to upload files, you can append the uploaded files as FormData and send an XHR request. Here is the [implementation code](https://github.com/frappe/frappe/blob/421f070e78ee1186e7f2f4b2575d8be1d3e2d646/frappe/public/js/frappe/file_uploader/FileUploader.vue#L381-L401) in Frappe Desk.", "content_type": "mixed", "has_code": true, "token_count": 168}
{"chunk_id": "06_python_api__api__full-text-search__001", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/full-text-search", "title": "Full Text Search", "section_heading": "`update_index_by_name(self, doc_name)`", "content": "## `update_index_by_name(self, doc_name)`\n\nFrappe Wrapper for [Whoosh](https://pypi.org/project/Whoosh/)\n\n### `update_index_by_name(self, doc_name)`\n\nWraps `update_index` method, gets the document from name and updates the index. This function changes the current user and should only be run as administrator or in a background job.\n\nArgs:\n\n* self (object): FullTextSearch Instance\n* doc\\_name (str): name of the document to be updated\n\n### `remove_document_from_index(self, doc_name)`\n\nRemove document from search index\n\nArgs:\n\n* self (object): FullTextSearch Instance\n* doc\\_name (str): name of the document to be removed\n\n### `update_index(self, document)`\n\nUpdate search index for a document\n\nArgs:\n\n* self (object): FullTextSearch Instance\n* document (\\_dict): A dictionary with title, path and content\n\n### `build_index(self)`\n\nBuild index for all parsed documents\n\n### `search(self, text, scope=None, limit=20)`\n\nSearch from the current index\n\nArgs:\n\n* text (str): String to search for\n* scope (str, optional): Scope to limit the search. Defaults to None.\n* limit (int, optional): Limit number of search results. Defaults to 20.\n\nReturns:\n\n* [list(\\_dict)]: Search results", "content_type": "prose", "has_code": false, "token_count": 294}
{"chunk_id": "06_python_api__api__py-dialog__001", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/py-dialog", "title": "Py Dialog", "section_heading": "frappe.msgprint", "content": "## frappe.msgprint\n\nFrappe provides a group of standard, interactive and flexible dialogs that are\neasy to configure and use. There's also a more extensive API for [Javascript](/framework/v14/user/en/api/dialog).\n\n### frappe.msgprint\n\n`frappe.msgprint(msg, title, raise_exception, as_table, as_list, indicator, primary_action)`\n\nThis method works only within a request / response cycle. It shows a message to\nthe user logged in to Desk who initiated the request.\n\nThe argument list includes:\n\n* `msg`: The message to be displayed\n* `title`: Title of the modal\n* `as_table`: If `msg` is a list of lists, render as HTML table\n* `as_list`: If `msg` is a list, render as HTML unordered list\n* `primary_action`: Bind a primary server/client side action.\n* `raise_exception`: Exception\n\n```python\nfrappe.msgprint(\n msg='This file does not exist',\n title='Error',\n raise_exception=FileNotFoundError\n)\n```\n\n![frappe.msgprint](/files/dialog-api-msgprint-py.png)\n*frappe.msgprint*\n\n`primary_action` can contain a `server_action` **or** `client_side` action which\nmust contain dotted paths to the respective methods. The JavaScript function\nmust be a globally available function.\n\n```python\n# msgprint with server and client side action\nfrappe.msgprint(msg='This file does not exist',\n title='Error',\n raise_exception=FileNotFoundError\n primary_action={\n 'label': _('Perform Action'),\n 'server_action': 'dotted.path.to.server.method',\n 'client_action': 'dotted.path.to.client.method',\n 'args': args\n }\n)\n```\n\n![frappe.msgprint with primary action](/files/dialog-api-msgprint-py-with-primary-action.png)\n*frappe.msgprint with primary action*", "content_type": "mixed", "has_code": true, "token_count": 407}
{"chunk_id": "06_python_api__api__py-dialog__002", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/py-dialog", "title": "Py Dialog", "section_heading": "frappe.throw", "content": "## frappe.throw\n\n`frappe.throw(msg, exc, title)`\n\nThis method will raise an exception as well as show a message in Desk. It is\nessentially a wrapper around `frappe.msgprint`.\n\n`exc` can be passed an optional exception. By default it will raise a `ValidationError` exception.\n\n```python\nfrappe.throw(\n title='Error',\n msg='This file does not exist',\n exc=FileNotFoundError\n)\n```\n\n![Throw-py](/files/dialog-api-msgprint-py.png)\n*frappe.throw*", "content_type": "mixed", "has_code": true, "token_count": 110}
{"chunk_id": "06_python_api__api__query-builder__001", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/query-builder", "title": "Query Builder", "section_heading": "frappe.qb", "content": "## frappe.qb\n\n`frappe.qb` is a query builder written around PyPika to build a single interface for cross-db queries\n\nWhile developing apps, you'll often need to retrieve some specific data from the database. One way to do this is to use `frappe.db.sql` and write raw SQL queries.\n\nMaybe something like\n\n```python\nresult = frappe.db.sql(\n f\"\"\"\n SELECT `path`,\n COUNT(*) as count,\n COUNT(CASE WHEN CAST(`is_unique` as Integer) = 1 THEN 1 END) as unique_count\n FROM `tabWeb Page View`\n WHERE `creation` BETWEEN {some_date} AND {some_later_date}\n \"\"\"\n)\n```\n\nThe query builder API makes this easier by providing a simple pythonic API to build SQL queries without limiting the flexibility of handwritten SQL.\n\nThe same query in the query builder would look something like\n\n```python\nimport frappe\nfrom frappe.query_builder import DocType\nfrom frappe.query_builder.functions import Count\nfrom pypika.terms import Case\n\nWebPageView = DocType(\"Web Page View\") # you can also use frappe.qb.DocType to bypass an import\n\ncount_all = Count('*').as_(\"count\")\ncase = Case().when(WebPageView.is_unique == \"1\", \"1\")\ncount_is_unique = Count(case).as_(\"unique_count\")\n\nresult = (\n frappe.qb.from_(WebPageView)\n .select(WebPageView.path, count_all, count_is_unique)\n .where(Web_Page_View.creation[some_date:some_later_date])\n).run()\n```\n\n### frappe.qb\n\nReturns a Pypika query object which lets you build queries. Queries built using this object will be a\ntype from `pypika.dialects`, sprinkled with some Frappe sugar. Some of its methods are:", "content_type": "mixed", "has_code": true, "token_count": 380}
{"chunk_id": "06_python_api__api__query-builder__002", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/query-builder", "title": "Query Builder", "section_heading": "frappe.qb.from\\_(doctype)", "content": "## frappe.qb.from\\_(doctype)\n\nlets you construct a from query to select data\n\n**Select query**\n\n```python\nquery = frappe.qb.from_('Customer').select('id', 'fname', 'lname', 'phone')\n```\n\nThe SQL query built is\n\n```python\nSELECT `id`,`fname`,`lname`,`phone` FROM `tabCustomer`\n```\n\n**A complex Select example**\n\n```python\ncustomers = frappe.qb.DocType('Customer')\nq = (\n frappe.qb.from_(customers)\n .select(customers.id, customers.fname,customers.lname, customers.phone)\n .where((customers.fname == 'Max') | (customers.id.like('RA%')) )\n .where(customers.lname == 'Mustermann')\n)\n```\n\nThe SQL query built is\n\n```python\nSELECT `id`,`fname`,`lname`,`phone` FROM `tabCustomer` WHERE (`fname`='Max' OR `id` LIKE 'RA%') AND `lname`='Mustermann'\n```\n\nSome noteworthy things\n\n* We have created a `customers` variable to refer to the table in the query.\n* Select can take any number of arguments, selecting various Fields.\n* The '|' (pipe) or '&' (ampersand) operators can be used to refer to 'OR' or 'AND'.\n* Chaining the `where()` method appends 'AND' by default\n\nYou can read more about the other functions at the [Pypika](https://github.com/kayak/pypika) repo.\n\n### frappe.qb.Doctype(name\\_of\\_table)\n\nReturns a PyPika table object which can be used elsewhere. It will automatically add 'tab' if necessary.\n\n### frappe.qb.Table(name\\_of\\_table)\n\nDoes the same thing as `frappe.qb.DocType` but will not append 'tab'. It's intended to be used with '\\_\\_Auth' like tables.\n\n> Note: You should only use this if you know what you are doing.\n\n### frappe.qb.Field(name\\_of\\_coloum)\n\nReturn a PyPika field object, this represents a column. They are usually used to compare columns with values.\n\nOne example would be\n\n```python\nlname = frappe.qb.Field(\"lname\")\nq = frapppe.qb.from_(\"customers\").select(\"*\").where(lname == 'Mustermann')\n```", "content_type": "mixed", "has_code": true, "token_count": 456}
{"chunk_id": "06_python_api__api__query-builder__003", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/query-builder", "title": "Query Builder", "section_heading": "Executing queries", "content": "## Executing queries\n\nQueries built using the `frappe.qb` namespace are PyPika objects. They will have to be converted to string objects so that your database management system can recognize them.\n\nTo check how your query object translates, you can type cast it with `str` or use the `.get_sql` method they come with.\n\n```python\nquery = frappe.qb.from_('Customer').select('id', 'fname', 'lname', 'phone')\n\nstr(query)\n# SELECT \"id\",\"fname\",\"lname\",\"phone\" FROM \"tabCustomer\"\n\nquery.get_sql()\n# SELECT \"id\",\"fname\",\"lname\",\"phone\" FROM \"tabCustomer\"\n\nstr(query) == query.get_sql()\n# True\n```\n\n### Walk method\n\nAll queries built through `frappe.qb` are parameterized by default. All input fields, raw values, and functions are separated as Named parameters and sent to the database as a dictionary. Parameterization is done to sanitize queries which would prevent SQL injections.\n\nYou use the `walk` method to check out which parts are parameterized. It returns the parameterized query and the corresponding dictionary.\n\n```python\ndoctype = frappe.qb.DocType(\"DocType\")\n\nfrappe.qb.from_(doctype).select('*').where(doctype.name == \"somename\").walk()\n# ('SELECT * FROM `tabDocType` WHERE `name`=%(param1)s', {'param1': 'somename'})\n```", "content_type": "mixed", "has_code": true, "token_count": 307}
{"chunk_id": "06_python_api__api__query-builder__004", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/query-builder", "title": "Query Builder", "section_heading": "Run method", "content": "## Run method\n\nThis is the most preferred method to execute your queries. Every valid query has the `run` method which you\nmay use to execute the query with.\n\n```python\nfrappe.qb.from_('Customer').select('id', 'fname', 'lname', 'phone').run()\n```\n\nThe `run` method accepts `kwargs` which will be passed on while the query is being executed. You may pass whatever options are available in `frappe.db.sql`, through the `run` method.\n\nTo run debug on your query, or get the result in the form of List[Dict], you may use the following respectively:\n\n```python\nIn [7]: frappe.qb.from_('ToDo').select('name').run(debug=True)\nSELECT \"name\" FROM \"tabToDo\"\nExecution time: 0.0 sec\nOut[7]: [('8d765f73a2',)]\n\nIn [8]: frappe.qb.from_('ToDo').select('name').run(as_dict=True)\nOut[8]: [{'name': '8d765f73a2'}]\n```\n\n> The `run` method internally calls the lower level `frappe.db.sql` API.\n\n### frappe.db.sql\n\nou may choose to directly pass your query objects to `frappe.db.sql` too. This ignores permisions and paramaterisation of queries.\n\n```python\nquery = frappe.qb.from_('Customer').select('id', 'fname', 'lname', 'phone')\nfrappe.db.sql(query)\n```\n\n### frappe.query\\_builder.functions\n\nThis module provides standard functions you might need while building queries, like `Count()` and `Sum().`", "content_type": "mixed", "has_code": true, "token_count": 320}
{"chunk_id": "06_python_api__api__query-builder__005", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/query-builder", "title": "Query Builder", "section_heading": "Joins and Sub-queries", "content": "## Joins and Sub-queries\n\nYou can check [pypika documentation](https://pypika.readthedocs.io/en/latest/2_tutorial.html#joining-tables-and-subqueries) to join tables and add subqueries. Instead of `Table`, use `frappe.qb.DocType`\n\nExample:\n\n```python\nHasRole = frappe.qb.DocType('Has Role')\nCustomRole = frappe.qb.DocType('Custom Role')\n\nquery = (frappe.qb.from_(HasRole)\n .inner_join(CustomRole)\n .on(CustomRole.name == HasRole.parent)\n .select(CustomRole.page, HasRole.parent, HasRole.role))\n```\n\n### Simple functions\n\nSay you want to count all the entries in a Notes table. You could do something like\n\n```python\nfrom frappe.query_builder.functions import Count\n\nNotes = frappe.qb.DocType(\"Notes\")\ncount_pages = Count(Notes.content).as_(\"Pages\")\n\nresult = frappe.qb.from_(Notes).select(count_pages).run(as_dict=True)\n```\n\n### Custom Functions\n\n`frappe.query_builder.functions` is a superset of `pypika.functions`, so it has all PyPika functions and some custom ones we made. You can make your custom functions by importing the `CustomFunction` class from PyPika\n\nOne implementation of the DateDiff function\n\n```python\nfrom pypika import CustomFunction\n\ncustomers = Tables('Customer')\nDateDiff = CustomFunction('DATE_DIFF', ['interval', 'start_date', 'end_date'])\n\nq = Query.from_(customers).select(\n DateDiff('day', customers.created_date, customers.updated_date)\n)\n```\n\nIf we print `q`, we would get\n\n```python\nSELECT DATE_DIFF('day',\"created_date\",\"updated_date\") FROM \"Customer\"\n```\n\n> Notice how we specify arguments and the actual SQL text. The exact format might not work for more complex functions. The advanced section covers more complicated methods.\n\n### Constant Column\n\n`ConstantColumn` is a class to define a pseudo column with a constant value.\n\n```python\nfrom frappe.query_builder.custom import ConstantColumn\n\nfrappe.qb.from_(\"DocType\").select(\"name\", ConstantColumn(\"john\").as_(\"user\"))\n# SELECT `name`,'john' `user` FROM `tabDocType`\n```\n\nHere we define a column user with the value \"john.\"", "content_type": "mixed", "has_code": true, "token_count": 502}
{"chunk_id": "06_python_api__api__query-builder__006", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/query-builder", "title": "Query Builder", "section_heading": "Special functions", "content": "## Special functions\n\nOne such function is [Match Against](https://mariadb.com/kb/en/match-against/). It's different because it has a chained against argument. To implement something like this you need to inherit from PyPika's `DistinctOptionFunction` class.\n\nThe current MATCH class looks something like\n\n```python\nfrom pypika.functions import DistinctOptionFunction\nfrom pypika.utils import builder\n\nclass MATCH(DistinctOptionFunction):\n def __init__(self, column: str, *args:\n super(MATCH, self)._init_(\" MATCH\", column, *args)\n self._Against = False\n\n def get_function_sql(self, **kwargs):\n s = super(DistinctOptionFunction, self).get_function_sql(**kwargs)\n\n if self._Against:\n return f\"{s} AGAINST (f'+{self._Against}*') IN BOOLEAN MODE)\"\n return s\n\n @builder\n def Against(self, text: str):\n self._Against = text\n```\n\n* The `__init__()` method works similar to CustomFunction class above. You mention all the arguments and the SQL text.\n* The `Against()` method only stores a value that will be used in the `get_function_sql()`\n* It also has the `@builder` wrapper. In short, it lets these functions be chainable by making a copy of the object.\n* We have wrapped the `get_function_sql()` method, which allows us to append the required SQL text for Against.\n* this can further be extended to use any number other chains.\n\nIn use, the Match class looks like this\n\n```python\nfrom frappe.query_builder.functions import Match\n\nmatch = Match(\"Coloum name\").Against(\"Some_text_match\")\n# MATCH('Coloum name') AGAINST ('+Some_text_match*' IN BOOLEAN MODE)\n```", "content_type": "mixed", "has_code": true, "token_count": 389}
{"chunk_id": "06_python_api__api__query-builder__007", "module": "06_python_api", "source_url": "https://docs.frappe.io/framework/v15/user/en/api/query-builder", "title": "Query Builder", "section_heading": "Utils", "content": "## Utils\n\n**ImportMapper(dict)**\n\nIn the rare case where you have different functions for different SQL dialects, Which do the same thing, you can use the ImportMapper Utility. It maps functions based on the SQL dialect, so one query works across different SQL dialects.\n\nIt takes in a dict which maps functions to databases.\n\nFor example the the mapping for GroupConat looks like this\n\n```python\nfrom frappe.query_builder.utils import ImportMapper, db_type_is\nfrom frappe.query_builder.custom import GROUP_CONCAT, STRING_AGG\n\nGroupConcat = ImportMapper(\n {\n db_type_is.MARIADB: GROUP_CONCAT,\n db_type_is.POSTGRES: STRING_AGG\n }\n)\n```", "content_type": "mixed", "has_code": true, "token_count": 158}
